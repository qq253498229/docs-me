<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 15 章 测试事件驱动型微服务 :: docs-me</title>
    <link rel="prev" href="14.html">
    <link rel="next" href="16.html">
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">docs-me</a>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs-building-event-driven-microservices" data-version="0.0.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="index.html">微服务与事件驱动架构</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="copyright.html">版权声明</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="o_reilly_media_inc_introduction.html">O&#8217;Reilly Media, Inc. 介绍</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="industry_evaluation.html">业界评论</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="introduction.html">前言</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="typesetting_convention.html">排版约定</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="o_reilly_online_learning_platform.html">O&#8217;Reilly在线学习平台（O&#8217;Reilly Online Learning）</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="contact_us.html">联系我们</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="acknowledgments.html">致谢</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="more_information.html">更多信息</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html">第 1 章 为什么用事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="1.html#_1_1_什么是事件驱动型微服务">1.1 什么是事件驱动型微服务</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_2_领域驱动设计和界限上下文">1.2 领域驱动设计和界限上下文</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_2_1_运用领域模型和界限上下文">1.2.1 运用领域模型和界限上下文</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_2_2_保持界限上下文与业务需求一致">1.2.2 保持界限上下文与业务需求一致</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_3_沟通结构">1.3 沟通结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_1_业务沟通结构">1.3.1 业务沟通结构</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_2_实现沟通结构">1.3.2 实现沟通结构</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_3_数据沟通结构">1.3.3 数据沟通结构</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_4_康威定律和沟通结构">1.3.4 康威定律和沟通结构</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_4_传统计算中的沟通结构">1.4 传统计算中的沟通结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_1_选项1创建一个新服务">1.4.1 选项1：创建一个新服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_2_选项2将它加入现有服务中">1.4.2 选项2：将它加入现有服务中</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_3_两种选项的利弊">1.4.3 两种选项的利弊</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_4_团队场景续">1.4.4 团队场景（续）</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_5_冲突的压力">1.4.5 冲突的压力</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_5_事件驱动的沟通结构">1.5 事件驱动的沟通结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_1_事件是通信的基础">1.5.1 事件是通信的基础</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_2_事件流提供了单一事实来源">1.5.2 事件流提供了单一事实来源</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_3_消费者执行自己的建模和查询">1.5.3 消费者执行自己的建模和查询</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_4_整个组织的数据沟通得到改善">1.5.4 整个组织的数据沟通得到改善</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_5_高可访问的数据利于业务变更">1.5.5 高可访问的数据利于业务变更</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_6_异步的事件驱动型微服务">1.6 异步的事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_使用事件驱动型微服务的示例团队">使用事件驱动型微服务的示例团队</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_7_同步式微服务">1.7 同步式微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_7_1_同步式微服务的缺点">1.7.1 同步式微服务的缺点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_7_2_同步式微服务的优点">1.7.2 同步式微服务的优点</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="1.html#_1_8_小结">1.8 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html">第 2 章 事件驱动型微服务基础</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_1_构建拓扑">2.1 构建拓扑</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_1_1_微服务拓扑">2.1.1 微服务拓扑</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_1_2_业务拓扑">2.1.2 业务拓扑</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_2_事件内容">2.2 事件内容</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_3_事件的结构">2.3 事件的结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_3_1_无键事件">2.3.1 无键事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_3_2_实体事件">2.3.2 实体事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_3_3_键控事件">2.3.3 键控事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_4_物化来自实体事件的状态">2.4 物化来自实体事件的状态</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_5_事件数据的定义和schema">2.5 事件数据的定义和schema</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_6_微服务单一写原则">2.6 微服务单一写原则</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_7_用事件代理赋能微服务">2.7 用事件代理赋能微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_7_1_事件存储和服务">2.7.1 事件存储和服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_7_2_需要考虑的其他因素">2.7.2 需要考虑的其他因素</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_8_事件代理与消息代理">2.8 事件代理与消息代理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_8_1_从不可变日志中消费">2.8.1 从不可变日志中消费</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_8_2_提供单一事实来源">2.8.2 提供单一事实来源</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_9_大规模管理微服务">2.9 大规模管理微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_9_1_将微服务放到容器内">2.9.1 将微服务放到容器内</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_9_2_将微服务放到虚拟机内">2.9.2 将微服务放到虚拟机内</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_9_3_管理容器和虚拟机">2.9.3 管理容器和虚拟机</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_10_缴纳微服务税">2.10 缴纳微服务税</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_11_小结">2.11 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="3.html">第 3 章 通信和数据契约</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="3.html#_3_1_事件驱动数据契约">3.1 事件驱动数据契约</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_1_使用显式schema作为契约">3.1.1 使用显式schema作为契约</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_2_schema定义的注释">3.1.2 schema定义的注释</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_3_全能的schema演化">3.1.3 全能的schema演化</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_4_有代码生成器支持">3.1.4 有代码生成器支持</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_5_破坏性的schema变更">3.1.5 破坏性的schema变更</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="3.html#_3_2_选择事件格式">3.2 选择事件格式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="3.html#_3_3_设计事件">3.3 设计事件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_1_只讲述事实">3.3.1 只讲述事实</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_2_每个流都使用单一事件定义">3.3.2 每个流都使用单一事件定义</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_3_使用最窄的数据类型">3.3.3 使用最窄的数据类型</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_4_保持事件的单一用途">3.3.4 保持事件的单一用途</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_5_最小化事件">3.3.5 最小化事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_6_让潜在的消费者参与事件设计">3.3.6 让潜在的消费者参与事件设计</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_7_避免将事件作为信号量或信号">3.3.7 避免将事件作为信号量或信号</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="3.html#_3_4_小结">3.4 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html">第 4 章 将事件驱动架构与现有系统集成</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_1_什么是数据解放">4.1 什么是数据解放</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_1_1_数据解放的折中方案">4.1.1 数据解放的折中方案</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_1_2_将被解放的数据转化成事件">4.1.2 将被解放的数据转化成事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_2_数据解放模式">4.2 数据解放模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_3_数据解放框架">4.3 数据解放框架</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_4_通过查询实施数据解放">4.4 通过查询实施数据解放</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_1_批量加载">4.4.1 批量加载</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_2_增量时间戳加载">4.4.2 增量时间戳加载</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_3_自增id加载">4.4.3 自增ID加载</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_4_自定义查询">4.4.4 自定义查询</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_5_增量更新">4.4.5 增量更新</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_6_基于查询更新的优点">4.4.6 基于查询更新的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_7_基于查询更新的缺点">4.4.7 基于查询更新的缺点</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_5_使用变更数据捕获日志解放数据">4.5 使用变更数据捕获日志解放数据</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_5_1_使用数据存储日志的优点">4.5.1 使用数据存储日志的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_5_2_使用数据库日志的缺点">4.5.2 使用数据库日志的缺点</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_6_使用发件箱表解放数据">4.6 使用发件箱表解放数据</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_1_性能考虑">4.6.1 性能考虑</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_2_隔离内部数据模型">4.6.2 隔离内部数据模型</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_3_确保schema兼容性">4.6.3 确保schema兼容性</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_4_使用触发器捕获变更数据">4.6.4 使用触发器捕获变更数据</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_7_对处于捕获的数据集做数据定义变更">4.7 对处于捕获的数据集做数据定义变更</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_7_1_为查询和cdc日志模式处理事后数据定义变更">4.7.1 为查询和CDC日志模式处理事后数据定义变更</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_7_2_为变更数据表捕获模式处理数据定义变更">4.7.2 为变更数据表捕获模式处理数据定义变更</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_8_将事件数据落地到数据存储">4.8 将事件数据落地到数据存储</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_9_数据落地和获取对业务的影响">4.9 数据落地和获取对业务的影响</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_10_小结">4.10 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html">第 5 章 事件驱动处理基础</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_1_构建无状态拓扑">5.1 构建无状态拓扑</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_1_1_转换">5.1.1 转换</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_1_2_分流与合流">5.1.2 分流与合流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_2_对事件流再分区">5.2 对事件流再分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_示例对一个事件流再分区">示例：对一个事件流再分区</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_3_对事件流协同分区">5.3 对事件流协同分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_示例对一个事件流进行协同分区">示例：对一个事件流进行协同分区</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_4_给消费者实例分配分区">5.4 给消费者实例分配分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_4_1_使用分区分配器分配分区">5.4.1 使用分区分配器分配分区</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_4_2_分配协同分区">5.4.2 分配协同分区</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_4_3_分区分配策略">5.4.3 分区分配策略</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="5.html#_5_5_从无状态处理实例故障中恢复">5.5 从无状态处理实例故障中恢复</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="5.html#_5_6_小结">5.6 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html">第 6 章 具有确定性的流处理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_1_事件驱动工作流的确定性">6.1 事件驱动工作流的确定性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_2_时间戳">6.2 时间戳</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_2_1_同步分布式时间戳">6.2.1 同步分布式时间戳</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_2_2_处理带时间戳的事件">6.2.2 处理带时间戳的事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_3_事件调度和确定性处理">6.3 事件调度和确定性处理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_1_自定义事件调度器">6.3.1 自定义事件调度器</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_2_基于事件时间处理时间和摄取时间进行处理">6.3.2 基于事件时间、处理时间和摄取时间进行处理</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_3_消费者提取时间戳">6.3.3 消费者提取时间戳</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_4_对外部系统的请求响应调用">6.3.4 对外部系统的“请求–响应”调用</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_4_水位">6.4 水位</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_并行处理中的水位">并行处理中的水位</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_5_流时间">6.5 流时间</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_并行处理中的流时间">并行处理中的流时间</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_6_乱序事件和迟到事件">6.6 乱序事件和迟到事件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_6_1_使用水位和流时间的迟到事件">6.6.1 使用水位和流时间的迟到事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_6_2_乱序事件的原因和影响">6.6.2 乱序事件的原因和影响</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_6_3_时间敏感的函数和窗口化">6.6.3 时间敏感的函数和窗口化</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_7_处理迟到事件">6.7 处理迟到事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_8_再处理与近实时处理">6.8 再处理与近实时处理</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_9_间歇性故障和迟到事件">6.9 间歇性故障和迟到事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_10_生产者事件代理的连接性问题">6.10 生产者/事件代理的连接性问题</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_11_小结与延展阅读">6.11 小结与延展阅读</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html">第 7 章 有状态的流</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="7.html#_7_1_状态存储与从事件流中物化状态">7.1 状态存储与从事件流中物化状态</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="7.html#_7_2_记录状态到变更日志事件流">7.2 记录状态到变更日志事件流</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_3_将状态物化至内部状态存储">7.3 将状态物化至内部状态存储</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_1_物化全局状态">7.3.1 物化全局状态</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_2_使用内部状态的优点">7.3.2 使用内部状态的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_3_使用内部状态的缺点">7.3.3 使用内部状态的缺点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_4_内部状态的伸缩和恢复">7.3.4 内部状态的伸缩和恢复</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_4_将状态物化至外部状态存储">7.4 将状态物化至外部状态存储</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_4_1_外部状态的优点">7.4.1 外部状态的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_4_2_外部状态的缺点">7.4.2 外部状态的缺点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_4_3_外部状态存储的伸缩和恢复">7.4.3 外部状态存储的伸缩和恢复</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_5_重建与迁移状态存储">7.5 重建与迁移状态存储</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_5_1_重建">7.5.1 重建</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_5_2_迁移">7.5.2 迁移</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_6_事务与有效一次处理">7.6 事务与有效一次处理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_6_1_示例库存计算服务">7.6.1 示例：库存计算服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_6_2_使用客户端代理事务的有效一次处理">7.6.2 使用“客户端–代理”事务的有效一次处理</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_6_3_没有客户端代理事务的有效一次处理">7.6.3 没有“客户端–代理”事务的有效一次处理</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="7.html#_7_7_小结">7.7 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html">第 8 章 用微服务构建工作流</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html#_8_1_编排模式">8.1 编排模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_1_1_一个简单的事件驱动编排示例">8.1.1 一个简单的事件驱动编排示例</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_1_2_创建和修改编排的工作流">8.1.2 创建和修改编排的工作流</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_1_3_监控编排的工作流">8.1.3 监控编排的工作流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html#_8_2_编制模式">8.2 编制模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_1_一个简单的事件驱动编制模式例子">8.2.1 一个简单的事件驱动编制模式例子</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_2_一个简单的直接调用的编制模式例子">8.2.2 一个简单的直接调用的编制模式例子</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_3_对比事件驱动编制模式和直接调用的编制模式">8.2.3 对比事件驱动编制模式和直接调用的编制模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_4_创建和修改编制工作流">8.2.4 创建和修改编制工作流</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_5_监控编制工作流">8.2.5 监控编制工作流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html#_8_3_分布式事务">8.3 分布式事务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_3_1_编排型事务saga模式">8.3.1 编排型事务：saga模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_3_2_编制型事务">8.3.2 编制型事务</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="8.html#_8_4_补偿工作流">8.4 补偿工作流</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="8.html#_8_5_小结">8.5 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="9.html">第 9 章 使用“函数即服务”的微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="9.html#_9_1_设计基于函数的微服务解决方案">9.1 设计基于函数的微服务解决方案</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_1_1_确保界限上下文的严格的成员关系">9.1.1 确保界限上下文的严格的成员关系</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_1_2_只在完成处理之后提交偏移量">9.1.2 只在完成处理之后提交偏移量</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_1_3_少即是多">9.1.3 少即是多</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_2_选择faas供应商">9.2 选择FaaS供应商</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_3_在函数之外构建微服务">9.3 在函数之外构建微服务</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_4_冷启动和热启动">9.4 冷启动和热启动</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="9.html#_9_5_用触发器启动函数">9.5 用触发器启动函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_5_1_基于新事件触发事件流监听器">9.5.1 基于新事件触发：事件流监听器</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_5_2_基于消费者组的滞后度触发">9.5.2 基于消费者组的滞后度触发</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_5_3_按调度表触发">9.5.3 按调度表触发</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_5_4_使用网络钩子触发">9.5.4 使用网络钩子触发</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_5_5_触发资源事件">9.5.5 触发资源事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_6_用函数执行业务工作">9.6 用函数执行业务工作</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_7_维持状态">9.7 维持状态</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="9.html#_9_8_调用其他函数的函数">9.8 调用其他函数的函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_8_1_事件驱动通信模式">9.8.1 事件驱动通信模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_8_2_直接调用模式">9.8.2 直接调用模式</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_9_终止和关闭">9.9 终止和关闭</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="9.html#_9_10_调整函数">9.10 调整函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_10_1_分配足够的资源">9.10.1 分配足够的资源</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_10_2_批量事件处理的参数">9.10.2 批量事件处理的参数</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_11_faas的伸缩方案">9.11 FaaS的伸缩方案</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_12_小结">9.12 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="10.html">第 10 章 基础的生产者和消费者微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="10.html#_10_1_bpc的适用场合">10.1 BPC的适用场合</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_1_集成现有遗留系统">10.1.1 集成现有遗留系统</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_2_不依赖于事件顺序的有状态的业务逻辑">10.1.2 不依赖于事件顺序的有状态的业务逻辑</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_3_当数据层完成大部分工作时">10.1.3 当数据层完成大部分工作时</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_4_处理层和数据层独立伸缩">10.1.4 处理层和数据层独立伸缩</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="10.html#_10_2_具有外部流处理的混合bpc应用程序">10.2 具有外部流处理的混合BPC应用程序</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_示例使用外部流处理框架来联结事件流">示例：使用外部流处理框架来联结事件流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="10.html#_10_3_小结">10.3 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="11.html">第 11 章 使用重量级框架的微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_1_重量级框架的简单历史">11.1 重量级框架的简单历史</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_2_重量级框架的内部运作">11.2 重量级框架的内部运作</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_3_优点和局限性">11.3 优点和局限性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="11.html#_11_4_集群搭建方案和执行模式">11.4 集群搭建方案和执行模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_4_1_使用托管服务">11.4.1 使用托管服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_4_2_构建自己的完整集群">11.4.2 构建自己的完整集群</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_4_3_使用cms集成来创建集群">11.4.3 使用CMS集成来创建集群</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="11.html#_11_5_应用程序提交模式">11.5 应用程序提交模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_5_1_驱动器模式">11.5.1 驱动器模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_5_2_集群模式">11.5.2 集群</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_6_处理状态和使用检查点">11.6 处理状态和使用检查点</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="11.html#_11_7_伸缩应用程序和处理事件流分区">11.7 伸缩应用程序和处理事件流分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_7_1_伸缩运行中的应用程序">11.7.1 伸缩运行中的应用程序</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_7_2_通过重启伸缩应用程序">11.7.2 通过重启伸缩应用程序</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_7_3_自动伸缩应用程序">11.7.3 自动伸缩应用程序</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_8_从故障中恢复">11.8 从故障中恢复</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_9_考虑多租户问题">11.9 考虑多租户问题</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_10_语言和语法">11.10 语言和语法</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_11_选择一个框架">11.11 选择一个框架</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_12_示例点击和观看的会话窗口">11.12 示例：点击和观看的会话窗口</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_13_小结">11.13 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="12.html">第 12 章 使用轻量级框架的微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_1_优点和局限性">12.1 优点和局限性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_2_轻量级处理">12.2 轻量级处理</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_3_处理状态和使用变更日志">12.3 处理状态和使用变更日志</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="12.html#_12_4_伸缩和故障恢复">12.4 伸缩和故障恢复</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_4_1_事件洗牌">12.4.1 事件洗牌</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_4_2_状态分配">12.4.2 状态分配</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_4_3_状态复制和热副本">12.4.3 状态复制和热副本</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="12.html#_12_5_选择一个轻量级框架">12.5 选择一个轻量级框架</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_5_1_apache_kafka_streams">12.5.1 Apache Kafka Streams</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_5_2_apache_samza嵌入模式">12.5.2 Apache Samza：嵌入模式</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_6_语言和语法">12.6 语言和语法</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_7_流表表联结增强模式">12.7 流–表–表联结：增强模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_8_小结">12.8 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html">第 13 章 集成事件驱动型和“请求–响应”型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_1_处理外部事件">13.1 处理外部事件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_1_1_自动生成的事件">13.1.1 自动生成的事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_1_2_由响应生成的事件">13.1.2 由响应生成的事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_2_处理自动生成的分析事件">13.2 处理自动生成的分析事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_3_集成第三方请求响应api">13.3 集成第三方“请求–响应”API</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_4_处理并提供有状态的数据">13.4 处理并提供有状态的数据</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_4_1_实时请求内部状态存储">13.4.1 实时请求内部状态存储</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_4_2_实时请求外部状态存储">13.4.2 实时请求外部状态存储</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_5_在事件驱动的工作流中处理请求">13.5 在事件驱动的工作流中处理请求</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_处理用户界面事件">处理用户界面事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_6_请求响应应用程序中的微前端">13.6 “请求–响应”应用程序中的微前端</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_7_微前端的优点">13.7 微前端的优点</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_7_1_基于组合的微服务">13.7.1 基于组合的微服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_7_2_容易与业务需求对齐">13.7.2 容易与业务需求对齐</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_8_微前端的缺点">13.8 微前端的缺点</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_8_1_可能不一致的ui元素和样式">13.8.1 可能不一致的UI元素和样式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_8_2_不同的微前端性能">13.8.2 不同的微前端性能</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_8_3_示例体验搜索与评论应用程序">13.8.3 示例：体验搜索与评论应用</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_9_小结">13.9 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="14.html">第 14 章 支持性工具</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_1_微服务团队分配系统">14.1 微服务–团队分配系统</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_2_事件流的创建和修改">14.2 事件流的创建和修改</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_3_事件流元数据标记">14.3 事件流元数据标记</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_4_限额">14.4 限额</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_5_schema注册表">14.5 schema注册表</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_6_schema创建和修改通知">14.6 schema创建和修改通知</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_7_偏移量管理">14.7 偏移量管理</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_8_事件流的权限和访问控制列表">14.8 事件流的权限和访问控制列表</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_9_状态管理和应用程序重置">14.9 状态管理和应用程序重置</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_10_消费者偏移量滞后度监控">14.10 消费者偏移量滞后度</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_11_流水线型的微服务创建流程">14.11 流水线型的微服务创建流程</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_12_容器管理控制">14.12 容器管理控制</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="14.html#_14_13_集群创建和管理">14.13 集群创建和管理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_1_事件代理的程序化创建">14.13.1 事件代理的程序化创建</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_2_计算资源的程序化创建">14.13.2 计算资源的程序化创建</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_3_跨集群事件数据复制">14.13.3 跨集群事件数据复制</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_4_工具的程序化创建">14.13.4 工具的程序化创建</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="14.html#_14_14_依赖跟踪和拓扑可视化">14.14 依赖跟踪和拓扑可视化</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_拓扑示例">拓扑示例</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_15_小结">14.15 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="15.html">第 15 章 测试事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_15_1_通用测试原则">15.1 通用测试原则</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#_15_2_单元测试拓扑函数">15.2 单元测试拓扑函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_15_2_1_无状态的函数">15.2.1 无状态的函数</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_15_2_2_有状态的函数">15.2.2 有状态的函数</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_15_3_测试拓扑">15.3 测试拓扑</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_15_4_测试schema演化和兼容性">15.4 测试schema演化和兼容性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_15_5_事件驱动型微服务的集成测试">15.5 事件驱动型微服务的集成测试</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#_15_6_本地集成测试">15.6 本地集成测试</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_15_6_1_在测试代码的运行时内创建临时环境">15.6.1 在测试代码的运行时内创建临时环境</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_15_6_2_在测试代码外部创建临时环境">15.6.2 在测试代码外部创建临时环境</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_15_6_3_使用mocking和模拟器方法集成托管服务">15.6.3 使用mocking和模拟器方法集成托管</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_15_6_4_集成没有本地支持的远程服务">15.6.4 集成没有本地支持的远程服务</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#_15_7_完全远程集成测试">15.7 完全远程集成测试</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_15_7_1_程序化创建临时集成测试环境">15.7.1 程序化创建临时集成测试环境</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_15_7_2_使用共享环境进行测试">15.7.2 使用共享环境进行测试</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_15_7_3_使用生产环境进行测试">15.7.3 使用生产环境进行测试</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_15_8_选择你的完全远程集成测试策略">15.8 选择你的完全远程集成测试策略</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_15_9_小结">15.9 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="16.html">第 16 章 部署事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_1_微服务部署的原则">16.1 微服务部署的原则</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="16.html#_16_2_微服务部署的架构组件">16.2 微服务部署的架构组件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_2_1_持续集成系统持续交付系统和持续部署系统">16.2.1 持续集成系统、持续交付系统和持续部署</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_2_2_cms和商业硬件">16.2.2 CMS和商业硬件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_3_基本的全站式部署模式">16.3 基本的全站式部署模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_4_滚动更新模式">16.4 滚动更新模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="16.html#_16_5_破坏性的schema变更模式">16.5 破坏性的schema变更模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_5_1_通过两个事件流达到最终迁移">16.5.1 通过两个事件流达到最终迁移</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_5_2_同步迁移到新事件流">16.5.2 同步迁移到新事件流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_6_蓝绿部署模式">16.6 蓝绿部署模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_7_小结">16.7 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="17.html">第 17 章 结论</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_1_通信层">17.1 通信层</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_2_业务领域和界限上下文">17.2 业务领域和界限上下文</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_3_可共享的工具和基础设施">17.3 可共享的工具和基础设施</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_4_结构化事件">17.4 结构化事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_5_数据解放和单一事实来源">17.5 数据解放和单一事实来源</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_6_微服务">17.6 微服务</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_7_微服务实现方案">17.7 微服务实现方案</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_8_测试">17.8 测试</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_9_部署">17.9 部署</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_10_结语">17.10 结语</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="about_author.html">关于作者</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="about_cover.html">关于封面</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">微服务与事件驱动架构</span>
    <span class="version">0.0.1</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../docs-config/0.0.1/index.html">docs-config</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-config/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-steam-electron/0.0.1/index.html">docs-steam-electron</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-steam-electron/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-xiuxian/0.0.1/index.html">docs-xiuxian</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-xiuxian/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-es-java/7.16.0/introduction.html">ES Java API Client</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-es-java/7.16.0/introduction.html">7.16.0</a>
        </li>
        <li class="version">
          <a href="../../docs-es-java/6.8.0/preface.html">6.8.0</a>
        </li>
        <li class="version">
          <a href="../../docs-es-java/6.2.2/1Preface/readme.html">6.2.2</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-greenworks-js/0.0.1/index.html">Greenworks-JS 文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-greenworks-js/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-rust-libp2p/0.0.1/index.html">libp2p入门</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-rust-libp2p/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-neutralino-api/0.0.1/index.html">NeutralinoJS 文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-neutralino-api/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-antora-oauth2.1/0.0.1/index.html">OAuth 2.1 授权框架</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-antora-oauth2.1/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-pd2/0.0.1/index.html">PD2记录</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-pd2/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-peerjs/0.0.1/index.html">PEER JS</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-peerjs/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-actuator/3.3.3/index.html">Spring Boot Actuator</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-actuator/3.3.3/index.html">3.3.3</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-oauth2/0.0.1/index.html">Spring Boot OAuth2</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-oauth2/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-steamworks-rs/0.11.0/index.html">Steamworks for Rust</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-steamworks-rs/0.11.0/index.html">0.11.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-tauri/v1/index.html">Tauri API 文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-tauri/v1/index.html">v1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-testing-angular/中文/start.html">Testing Angular</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-testing-angular/中文/start.html">中文</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-me/0.0.1/index.html">个人记录</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-me/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-taiwu/0.0.1/index.html">太吾绘卷</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-taiwu/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-palworld/0.0.1/index.html">幻兽帕鲁笔记</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-palworld/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="index.html">微服务与事件驱动架构</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-hunter/0.0.1/index.html">猎人-荒野的呼唤</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-hunter/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-logitech/v8.45/index.html">罗技鼠标宏文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-logitech/v8.45/index.html">v8.45</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-milk/0.0.1/index.html">银河奶牛</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-milk/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../docs-me/0.0.1/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">微服务与事件驱动架构</a></li>
    <li><a href="15.html">第 15 章 测试事件驱动型微服务</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="https://github.com/qq253498229/docs-building-event-driven-microservices/edit/master/modules/ROOT/pages/15.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="目录" data-levels="3">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">第 15 章 测试事件驱动型微服务</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>测试事件驱动型微服务的一大优点是它们非常模块化。服务的输入由事件流或来自“请求–响应”API 的请求所提供。状态被物化到服务自己的独立的状态存储，输出事件则被写入服务的输出流中。微服务的“小”和“目标明确”的特性使得它们比大而复杂的服务更易于测试。这种微服务要移动的部件较少，处理 I/O 和状态的方法相对标准，并且有很多机会与其他微服务复用测试工具。本章涵盖测试原则和策略，包括单元测试、集成测试和性能测试。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_1_通用测试原则"><a class="anchor" href="#_15_1_通用测试原则"></a>15.1 通用测试原则</h2>
<div class="sectionbody">
<div class="paragraph">
<p>事件驱动型微服务会共享所有应用程序都通用的测试最佳实践。功能性测试，比如单元测试、集成测试、系统测试和回归测试，可以确保微服务做它应该做的事情。非功能性测试，比如性能测试、负载测试、压力测试和恢复测试，能够确保微服务在各种环境场景中按预期运行。</p>
</div>
<div class="paragraph">
<p>现在，在进一步讨论之前需要注意，本章是关于测试原理和操作方法的更广泛内容的一部分。毕竟，关于测试的图书、博客和文档有很多，我当然不能像它们那样涵盖测试的内容。本章主要介绍特定于事件驱动的测试方法和原则，以及它们如何集成到总体测试蓝图中。请参考关于特定语言测试框架和测试最佳实践的资料，以补充本章的内容。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_2_单元测试拓扑函数"><a class="anchor" href="#_15_2_单元测试拓扑函数"></a>15.2 单元测试拓扑函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>单元测试用于测试应用程序代码中的最小片段以确保它们正常工作。这些小型测试单元为编写更大、更全面的测试，以测试应用程序的更高级功能提供了基础。事件驱动拓扑通常会将转换、聚合、映射和归约函数应用于事件，这些函数是单元测试的理想候选函数。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
请确保为每个函数测试边界条件，比如 null 和最大值等。</p>
</div>
<div class="sect2">
<h3 id="_15_2_1_无状态的函数"><a class="anchor" href="#_15_2_1_无状态的函数"></a>15.2.1 无状态的函数</h3>
<div class="paragraph">
<p>无状态的函数不需要来自前面的函数调用的持久化状态，所以可以很容易地进行独立测试。以下代码显示了一个 EDM 拓扑的示例，该示例类似于在 map reduce 类型的框架中的拓扑。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>myInputStream
    .filter(myFilterFunction)
    .map(myMapFunction)
    .to(outputStream)</pre>
</div>
</div>
<div class="paragraph">
<p>myMapFunction 和 myFilterFunction 是独立的函数，它们都不保存状态。每个函数都应该进行单元测试，以确保其正确地处理预期范围内的输入数据，特别是边界情况。</p>
</div>
</div>
<div class="sect2">
<h3 id="_15_2_2_有状态的函数"><a class="anchor" href="#_15_2_2_有状态的函数"></a>15.2.2 有状态的函数</h3>
<div class="paragraph">
<p>有状态的函数的测试通常会比无状态的函数的测试更复杂。状态会随着时间和输入事件而变化，所以必须仔细测试所有必要的有状态的边缘情况。有状态的单元测试还要求持久化状态（无论是模拟外部数据存储还是临时内部数据存储）在测试期间可用。</p>
</div>
<div class="paragraph">
<p>下面是一个在基础的生产者–消费者实现中可发现的有状态的聚合函数例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public Long addValueToAggregation(String key, Long eventValue) {
    //数据存储需要能够用于单元测试环境
    Long storedValue = datastore.getOrElse(key, 0L);
    //对值加总并将其存回状态存储中
    Long sum = storedValue + eventValue;
    datastore.upsert(key, sum);
    return sum;
}</pre>
</div>
</div>
<div class="paragraph">
<p>该函数用于对每个键的 eventValue 求和。模拟端点是在测试期间提供数据存储的可靠实现的一种方法。另一种方法是创建一个本地可用的数据存储版本，不过这更类似于集成测试，稍后将详细介绍。无论是哪种情况，都必须仔细考虑此数据存储需要做什么，以及它与运行时使用的实际实现的关系。模拟的方法通常都能工作得很好，因为它允许进行非常高性能的单元测试，而不必为构建数据存储的完整实现而增加开销。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_3_测试拓扑"><a class="anchor" href="#_15_3_测试拓扑"></a>15.3 测试拓扑</h2>
<div class="sectionbody">
<div class="paragraph">
<p>功能完整的轻量级框架和重量级框架通常提供了本地测试整个拓扑的方法。如果你的框架没有提供，那么用户和贡献者社区可能已经创建了提供此功能的第三方选项（这是选择具有强大社区性框架的另一个原因）。例如，除了提供内置的 MemoryStream 类用于对流输入和输出进行细粒度控制，Apache Spark 还有两个不同的第三方单元测试选项，即 StreamingSuiteBase 和 spark-fast-tests。Apache Flink 提供了自己的拓扑测试选项，Apache Beam 也是如此。对于轻量级的流框架，Kafka Streams 提供了使用TopologyTestDriver 测试拓扑的方法，它模拟了框架的功能，而无须设置整个事件代理。</p>
</div>
<div class="paragraph">
<p>拓扑测试比单个单元测试更复杂，并且要执行特定业务逻辑的整个拓扑。你可以将你的拓扑想象成由多个可移动部件组成的单个、大型、复杂的函数。拓扑测试框架让你可以完全控制将哪些事件生产到输入流以及何时创建这些事件。你既可以生成带特定值的事件、乱序的事件、包含非法时间戳的事件，或者包含非法数据的事件，也可以生成用来测试边界逻辑的事件。这样才能确保基于时间的聚合、事件调度和有状态函数等操作按预期执行。</p>
</div>
<div class="paragraph">
<p>例如，考虑下面这个 MapReduce 类型的拓扑定义。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>myInputStream
    .map(myMapFunction)
    .groupByKey()
    .reduce(myReduceFunction)</pre>
</div>
</div>
<div class="paragraph">
<p>在这个拓扑中，消费的事件通过变量 myInputStream 表示。应用了一个映射函数，然后根据键将结果分组在一起，最后每个键简化为一个事件。虽然可以为 myMapFunction 和 myReduceFunction 实现单元测试，但它们不能轻松地再现 map、groupByKey 和 reduce 的框架操作，因为这些操作（以及其他操作）是框架的固有部分。</p>
</div>
<div class="paragraph">
<p>这就是拓扑测试发挥作用的地方。每个流框架对测试拓扑有不同程度的支持，你必须将可用的选项暴露出来。这些测试框架不需要你创建一个事件代理来维持输入事件或者搭建重量级框架集群来进行处理。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_4_测试schema演化和兼容性"><a class="anchor" href="#_15_4_测试schema演化和兼容性"></a>15.4 测试schema演化和兼容性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>根据任一事件流 schema 演化规则（参见 3.1.3 节），要确保所有输出 schema 与之前的 schema 兼容，你可以从 schema 注册表中提取 schema，并在代码提交过程中执行演化规则检查。一些应用程序可能使用 schema 生成工具在编译时从代码中定义的类或结构自动生成 schema，从而可自动与以前版本进行比较。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_5_事件驱动型微服务的集成测试"><a class="anchor" href="#_15_5_事件驱动型微服务的集成测试"></a>15.5 事件驱动型微服务的集成测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>微服务集成测试有两种主要形式：本地集成测试和远程集成测试。本地集成测试指在生产环境的本地化副本上执行的测试，远程集成测试指在本地系统外部的环境中执行的微服务。这两种形式都有许多优点和缺点，稍后将对此进行探讨。</p>
</div>
<div class="paragraph">
<p>第三种形式是一种混合选项，其中微服务及其测试环境的某些部分在本地托管或执行，其他部分在远程执行。由于技术上不可能评估这种混合模式的所有组合和排列，因此本书只关注两种主要情况，如果有不同的需求，则由你自己决定。</p>
</div>
<div class="paragraph">
<p>在本章的剩余部分，你应该记住以下几个首要问题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>你希望从集成测试中得到什么？是不是验证“这个能运行吗”？抑或这是生产数据的冒烟测试吗？还是有更多复杂的工作流需要测试和验证？</p>
</li>
<li>
<p>你的微服务是否需要支持从输入流时间的最开始位置重新启动，例如由于错误而导致的数据完全丢失或再处理？如果是这样，那么为测试这个功能是否按预期工作，你需要知道些什么？你可能还需要验证输入事件流是否能够支持此需求。</p>
</li>
<li>
<p>你需要什么数据来确定成功或失败？手动编制的事件数据是否足够？需要以编程方式创建吗？需要真实的生产数据吗？如果是，需要多少？</p>
</li>
<li>
<p>你是否有任何性能、负载、吞吐量或伸缩方面的问题需要测试？</p>
</li>
<li>
<p>你将如何确保构建的每个微服务不需要一个完整的自建集成测试解决方案？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>接下来的内容将有助于你了解一些可用的选项，以便对这些问题给出自己的答案。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_6_本地集成测试"><a class="anchor" href="#_15_6_本地集成测试"></a>15.6 本地集成测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本地集成测试允许进行大范围的功能性测试和非功能性测试。测试的形式是使用生产环境的本地副本，其中微服务会部署在上面。这意味着至少要创建一个事件代理、schema 注册表、所有特定于微服务的数据存储、微服务本身以及任何所需的处理框架（比如当你使用重量级框架或 FaaS 时）。你还可以引入容器化、日志记录，甚至 CMS，但它们与微服务的业务逻辑没有严格的关系，因此不是绝对必要的。</p>
</div>
<div class="paragraph">
<p>构建自己的本地可控环境的最大好处是可以独立地控制每个系统。你可以以编程方式创建在实际生产环境会出现的场景，例如间歇性故障、乱序事件和网络访问丢失。你还可以测试框架与业务逻辑的集成。本地集成测试还提供了测试水平伸缩的基本功能的方法，特别是在涉及协同分区和状态的情况下。</p>
</div>
<div class="paragraph">
<p>本地集成测试的另一个显著好处是，你可以在相同的工作流中同时有效地测试事件驱动逻辑和“请求–响应”逻辑。你可以完全控制事件何时注入输入流中，并且在处理事件之前、期间或之后的任何时候发出请求。为了测试你的微服务，将“请求–响应”API 看作另一个事件源可能会有所帮助。</p>
</div>
<div class="paragraph">
<p>下面来看看每个系统部件能提供的一些选项。</p>
</div>
<div class="paragraph">
<p>事件代理</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建和删除事件流；</p>
</li>
<li>
<p>对输入流应用选择性事件排序以执行基于时间的逻辑、模拟无序事件和上游生产者故障；</p>
</li>
<li>
<p>修改分区数；</p>
</li>
<li>
<p>引发代理故障并恢复；</p>
</li>
<li>
<p>引发事件流可用性故障并恢复。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>schema 注册表</p>
</div>
<div class="ulist">
<ul>
<li>
<p>发布给定事件流的兼容演化的 schema，并使用它们生成输入事件；</p>
</li>
<li>
<p>引发故障并恢复。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>数据存储</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对现有的表进行 schema 变更（如果适用的话）；</p>
</li>
<li>
<p>对存储的过程进行变更（如果适用的话）；</p>
</li>
<li>
<p>当应用程序实例数被修改时重建内部状态（如果适用的话）；</p>
</li>
<li>
<p>引发故障并恢复。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>处理框架（如果适用的话）</p>
</div>
<div class="paragraph">
<p>应用程序和处理框架通常是交织在一起的，你可能需要为测试提供完整的框架实现，就像 FaaS 和重量级框架解决方案一样。框架提供的功能如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过内部事件流（轻量级）或洗牌机制（重量级）进行洗牌，以确保正确的协同分区和数据局部性；</p>
</li>
<li>
<p>检查点、故障以及从检查点恢复；</p>
</li>
<li>
<p>引发工作者实例故障以模拟丢失一个应用程序实例（重量级框架）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>应用程序</p>
</div>
<div class="paragraph">
<p>应用程序级别的控制主要涉及管理在任何给定时间运行的实例数。集成测试应该包含伸缩实例数（动态地，如果支持的话），以确保：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>再平衡的正常执行；</p>
</li>
<li>
<p>从检查点或变更日志流恢复内部状态，并保留了数据局部性；</p>
</li>
<li>
<p>外部状态访问不受影响；</p>
</li>
<li>
<p>“请求–响应”访问有状态的数据不会受应用程序实例数改变的影响。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对所有这些系统进行完全控制的目的是确保微服务在各种故障模式、不利条件和不同处理能力下仍能按预期工作。</p>
</div>
<div class="paragraph">
<p>执行本地集成测试有两种主要方式。第一种方式涉及嵌入测试库，这些库可以嵌入代码中。并不是所有微服务都适用这种方案，而且它们往往严重依赖于语言和框架支持。第二种方式涉及创建一个本地环境，其中安装了必要的组件，并且可以根据需要进行控制。下面先来看看这些方法，然后再研究依赖托管服务的测试微服务的方式。</p>
</div>
<div class="sect2">
<h3 id="_15_6_1_在测试代码的运行时内创建临时环境"><a class="anchor" href="#_15_6_1_在测试代码的运行时内创建临时环境"></a>15.6.1 在测试代码的运行时内创建临时环境</h3>
<div class="paragraph">
<p>将测试库嵌入代码中是迄今为止最受限的选项，尽管它可以很好地工作，不过这取决于客户端、代理和框架编程语言的兼容性如何。在这种方法中，测试代码会在与应用程序相同的可执行文件中启动必要的组件。</p>
</div>
<div class="paragraph">
<p>例如，Kafka Streams 应用程序的测试代码会启动自己的 Kafka 代理、schema 注册表和微服务拓扑实例。然后，测试代码可以启动并停止拓扑实例、发布事件、等待响应、导致代理中断以及引发其他故障模式。一旦终止，所有组件都被终止，状态将被清除。考虑以下伪代码（为简洁起见，略过声明和实例化）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>broker.start(brokerUrl, brokerPort, ...);
schemaRegistry.start(schemaRegistryUrl, srPort, ...);
//微服务的第一个实例
topologyOne.start(brokerUrl, schemaRegistryUrl,
    inputStreamOne, inputStreamTwo ...);

//同一个微服务的第二个实例
topologyTwo.start(brokerUrl, schemaRegistryUrl,
    inputStream, inputStreamTwo, ...);

//发布一些测试数据到输入流1
producer.publish(inputStreamOne, ...);
//发布一些测试数据到输入流2
producer.publish(inputStreamTwo, ...);
//等一段时间。这不是最好的办法，但你能够理解
Thread.sleep(5000);

//现在模拟topologyOne发生故障
topologyOne.stop();

//检查输出主题的输出。是否符合预期？

event = consumer.consume(outputTopic, ...)

//如果没有其他测试则关闭剩余的组件
topologyTwo.stop()
schemaRegistry.stop()
broker.stop()

if (event ...) //验证消费者输出
    //如果正确则通过测试
else
    //测试不通过</pre>
</div>
</div>
<div class="paragraph">
<p>Kafka Streams 是一个特别恰当的例子，因为它说明了这种方法的局限性。应用程序代码、代理和Confluent schema 注册表都是基于 JVM 的，因此你需要一个基于 JVM 的应用程序以编程方式控制同一运行时中的所有内容。其他开源的重量级框架也可以工作，尽管创建主实例和工作者实例需要一些额外的开销。请记住，由于这些重量级框架大部分也是基于 JVM 的，因此在撰写本书时，这种策略主要是一种只使用 JVM 的方法。虽然可以使用变通方法来测试非 JVM 应用程序，但这个过程并没有那么简单。</p>
</div>
</div>
<div class="sect2">
<h3 id="_15_6_2_在测试代码外部创建临时环境"><a class="anchor" href="#_15_6_2_在测试代码外部创建临时环境"></a>15.6.2 在测试代码外部创建临时环境</h3>
<div class="paragraph">
<p>设置环境以执行这些测试的一种方法是只需在本地安装和配置所有必需的系统。这是一种低开销的方法，特别是当你刚开始使用微服务时，但是如果每个团队成员都必须这样做，那么在他们每个人运行的版本略有不同的情况下，调试就会变得成本高昂且复杂。与大多数微服务一样，最好避免重复步骤，而是提供支持性工具以消除开销。</p>
</div>
<div class="paragraph">
<p>更灵活的方法是创建一个容器，其中安装并配置了所有必需的组件。所有想要以此方式测试应用程序的团队都可以使用这个容器。你可以维护一个开源贡献模型（即使是在组织内部），允许为所有团队添加修复、更新和新功能。这个模型非常灵活，可以与任何编程语言一起使用，不过与能够跟容器内部通信的可编程 API 一起使用要容易得多。轻量级处理框架示例如图 15-1 所示，其在容器内部创建了 schema 注册表、事件代理和必要的主题。微服务实例本身是在容器外部执行的，只需从其测试配置文件中引用代理和 schema 注册表的地址。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image511.png" alt="image511">
</div>
<div class="title">Figure 1. 图 15-1：使用容器化测试依赖项进行本地集成测试的轻量级微服务</div>
</div>
</div>
<div class="sect2">
<h3 id="_15_6_3_使用mocking和模拟器方法集成托管服务"><a class="anchor" href="#_15_6_3_使用mocking和模拟器方法集成托管服务"></a>15.6.3 使用mocking和模拟器方法集成托管服务</h3>
<div class="paragraph">
<p>本地集成测试环境可能也需要提供托管服务，比如托管的事件代理、重量级框架或 FaaS 平台。虽然一些托管服务有可运行的开源方案（比如开源的 Kafka），但不是所有的托管服务都能如此。例如，微软的Event Hubs、谷歌的 PubSub 和亚马逊的 Kinesis 都是专有且封闭的，无法下载完整的实现。在这种情况下，你所能做的就是使用这些公司或开源项目提供的模拟器、库或组件。</p>
</div>
<div class="paragraph">
<p>例如，谷歌的 PubSub 就有一个模拟器，其可以提供足够的本地测试功能，正如 LocalStack 提供的开源版本的 Kinesis（以及许多其他的亚马逊服务）一样。不幸的是，Microsoft Azure 的 Event Hubs 目前没有模拟器，也没有提供开源实现。然而，Azure Event Hub 客户端允许你使用 Apache Kafka 代替它，但并非所有功能都受支持。</p>
</div>
<div class="paragraph">
<p>FaaS 平台上的应用程序可以使用托管服务提供的本地测试库。谷歌云函数可以进行本地测试，亚马逊的Lambda 函数和 Microsoft Azure 的函数也可以进行本地测试。如第 9 章所述，开源解决方案OpenWhisk、OpenFaaS 和 Kubeless 提供了类似的测试机制，你可以通过 Web 搜索快速找到它们。这些方案使你可以在本地配置完整的 FaaS 环境，这样就可以在与生产环境尽可能类似的平台上进行测试了。</p>
</div>
<div class="paragraph">
<p>为使用重量级框架的应用程序搭建集成测试环境与为 FaaS 框架搭建集成测试环境很相似。它们都需要安装和配置框架，应用程序直接向框架提交处理作业。对于重量级框架，典型的单容器安装只需将主实例和工作者实例与事件代理和任何其他依赖项一起运行。当重量级框架搭建好之后，只需向主实例提交处理作业并等待输出事件流中的测试输出。图 15-2 展示了一个例子，其中整个依赖集已被容器化，以便在开发人员之间分发。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image512.png" alt="image512">
</div>
<div class="title">Figure 2. 图 15-2：使用容器化测试依赖项进行本地集成测试的重量级微服务</div>
</div>
</div>
<div class="sect2">
<h3 id="_15_6_4_集成没有本地支持的远程服务"><a class="anchor" href="#_15_6_4_集成没有本地支持的远程服务"></a>15.6.4 集成没有本地支持的远程服务</h3>
<div class="paragraph">
<p>在生产中使用的一些服务可能根本没有任何可用的本地方案，这对开发和集成测试来说都是缺点。一个现成的例子是 Microsoft Azure 的 Event Hub，它没有任何模拟器。缺乏本地可用的实现意味着除了这些应用程序的集成测试环境外，还必须为每个开发人员提供远程环境。这也是界线开始模糊的地方，因为到目前为止的集成测试主要是指将单个应用程序实例隔离在一个一次性且易于管理的本地环境中。在这个场景中产生的开销可能是独立开发和集成测试工作的真正障碍，所以在继续下一步之前一定要仔细考虑它。</p>
</div>
<div class="paragraph">
<p>缓解此问题通常需要与基础架构团队密切协调，以确保可以通过访问控制独立地调配测试环境，或者创建一个供所有人使用的大型公共环境（如本章后面所述，这有其自身的问题）。开发人员必须将本地临时环境连接到远程资源，但这可能会产生安全问题。清理和管理远程的临时环境也会出现问题。应对这一挑战的方法很多，但这种情况可能带来的问题太大，无法在这里全面解决。</p>
</div>
<div class="paragraph">
<p>好消息是，很多大型封闭源代码服务供应商正在努力提供本地的开发和测试方案，因此先行者们迟早都会有可用的方案。同时，请谨慎选择服务，并考虑其是否提供本地开发和集成测试选项。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_7_完全远程集成测试"><a class="anchor" href="#_15_7_完全远程集成测试"></a>15.7 完全远程集成测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>完全远程集成测试使你能够执行在本地环境中难以执行的特定测试。例如，性能和负载测试对于确保被测微服务实现其服务级别目标至关重要。事件处理吞吐量、“请求–响应”延迟、实例伸缩和故障恢复都可通过完全集成测试获得。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
完全集成测试的目标是创建一个尽可能接近生产环境的环境，包括应用程序运行中的事件流、事件数据量、事件 schema 和“请求–响应”模式（如果适用的话）。</p>
</div>
<div class="paragraph">
<p>完全集成测试通常使用以下三种方式中的一种。使用临时集成环境，一旦完成测试就丢弃它；使用共享的测试环境，该环境在集成测试之间持续存在，并由多个团队使用；使用生产环境本身来进行测试。</p>
</div>
<div class="sect2">
<h3 id="_15_7_1_程序化创建临时集成测试环境"><a class="anchor" href="#_15_7_1_程序化创建临时集成测试环境"></a>15.7.1 程序化创建临时集成测试环境</h3>
<div class="paragraph">
<p>14.13 节研究了以程序化方式生成事件代理和计算资源管理器的优势。你可以使用这些工具来生成集成测试的临时环境。可以创建一组单独的代理以及单独保留的计算资源来运行测试中的容器化微服务。使用这种方法进行完全集成测试的另一个好处是，它会定期执行创建新代理和计算环境的过程。这确保了脚本中发生的任何中断或配置中的任何缺陷都将在下一次集成测试中暴露出来。</p>
</div>
<div class="paragraph">
<p>在新搭建的环境中，下一个问题是缺少事件流和事件数据。毫无疑问，它们对于测试微服务是至关重要的。你可以通过直接询问用户或使用工具访问微服务代码库中的配置文件来获取要创建的事件流名称。分区数必须反映生产系统的分区数，以确保正确执行微服务的伸缩、协同分区和再分区逻辑。</p>
</div>
<div class="paragraph">
<p>一旦创建了事件流，下一步就是填充事件。这可以通过使用生产数据、特别策划的测试数据集或特别的编程生成的数据来实现。</p>
</div>
<div class="paragraph">
<p>1. 填充来自生产环境的事件</p>
</div>
<div class="paragraph">
<p>可以从生产集群复制事件到测试集群新创建的事件流中。这就是 14.13.3 节中描述的复制工具发挥作用的地方，因为可以使用相同的工具从生产环境中复制特定的事件流并加载事件。你必须说明可能阻止获取生产数据的任何安全和访问限制。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">优点</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>它准确反映了生产数据。</p>
</li>
<li>
<p>可以根据需要复制任意多或少的事件。</p>
</li>
<li>
<p>完全隔离的环境可以防止其他正在测试的微服务无意中影响你的测试。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">缺点</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>复制数据可能会影响生产性能，除非你已经充分规划并确立了代理的限额。</p>
</li>
<li>
<p>可能需要复制大量的数据，对长生命周期的实体来说更是如此。</p>
</li>
<li>
<p>你必须对包含敏感信息的事件流负责。</p>
</li>
<li>
<p>需要大量的投入来简化创建和复制过程，以减少使用障碍。</p>
</li>
<li>
<p>可能会暴露敏感的生产事件。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>2. 填充来自规划好的测试源的事件</p>
</div>
<div class="paragraph">
<p>规划好的事件让你可以在集成测试中使用具有特定属性、值以及与其他事件有关系的事件。这些事件需要存储在稳定且安全的地方，以使它们不会被意外或不经意地覆盖、破坏或丢失。此策略通常用于单个共享测试环境（稍后将详细介绍），但你也可以通过将事件从持久数据存储加载到用户指定的流中来应用它，这类似于从生产环境中复制事件。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">优点</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>涉及较小的数据集。</p>
</li>
<li>
<p>经过仔细的规划来确保有特定的值和关系。</p>
</li>
<li>
<p>对生产环境没有影响。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">缺点</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>要维护的开销很大。</p>
</li>
<li>
<p>数据会变过时。</p>
</li>
<li>
<p>必须处理新的事件流。</p>
</li>
<li>
<p>必须处理 schema 变更。</p>
</li>
<li>
<p>较少使用的事件流可能不可用。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>虽然这些缺点中有许多可以通过严格的操作流程来缓解，但这种策略往往最终会变成跟组织中的文档化倾向一样的形式。本来是令人满意的，但会变得过时、不一定相关，并且似乎总是比其他工作的优先级低。</p>
</div>
<div class="paragraph">
<p>3. 使用 schema 创建模拟的事件</p>
</div>
<div class="paragraph">
<p>程序化创建模拟的事件是另一种填充事件流的方法。你可以从 schema 注册表中获取 schema 并根据schema 定义生成事件。甚至可以获取较旧版本的 schema 并为其生成事件。</p>
</div>
<div class="paragraph">
<p>这种方法的复杂性来自要确保有与其他事件具有适当关系的事件，特别是如果有任何服务正在进行流之间的联结或在进行跨不同类型的事件的聚合。将多个事件联结在一起的微服务需要创建具有能匹配主键/外键的事件，才能正确地运行服务的联结逻辑。虽然这通常不是一个重要的问题（特别是因为微服务代码表达了业务逻辑所需的关系），但它确实需要这些数据的创建者来确保其范围正确，并且所有数据都属于预期的范围和值。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">优点</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>不需要生产集群来提供任何数据，也不会对生产性能有任何副作用。</p>
</li>
<li>
<p>你可以使用模糊化工具来创建事件数据、测试边界条件以及其他潜在的格式错误和半成品的格式字段。</p>
</li>
<li>
<p>你可以创建在生产数据中没有的特定的测试用例，以确保覆盖边界情况。</p>
</li>
<li>
<p>使你可以利用第三方工具（如 Confluent Avro）来程序化地创建测试数据。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">缺点</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>与其他方案相比需要花费更多精力来创建有关系的数据。</p>
</li>
<li>
<p>与生产环境中分布的数据相比，创建的数据仍然不是完全精准的。例如，由于模拟数据中没有体现键的分布，其可能跟生产数据的数据量存在严重差异。</p>
</li>
<li>
<p>创建的数据不能准确地表示某些字段。例如，以特定方式解析字符串字段的业务操作在使用创建的测试数据时可以通过，但在使用生产数据的子集时会失败。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_15_7_2_使用共享环境进行测试"><a class="anchor" href="#_15_7_2_使用共享环境进行测试"></a>15.7.2 使用共享环境进行测试</h3>
<div class="paragraph">
<p>另一个方案是创建一个单一的测试环境，其中包含一个共享的事件流池，所有的事件流都驻留在同一个事件代理中。这些流由表示生产数据子集的测试数据或前面所讨论的精心编制的测试数据填充。此方案提供了较低开销的测试环境，但将事件流和数据的管理工作转移到了应用程序开发人员身上。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">优点</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>很容易启动。</p>
</li>
<li>
<p>只需维护一个测试环境的基础设施。</p>
</li>
<li>
<p>与生产环境负载隔离。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">缺点</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>受制于“公地悲剧”。零碎和废弃的事件流会使你很难分辨哪些流对测试输入有效，哪些流只是以前未清理的测试的输出。</p>
</li>
<li>
<p>测试中的系统没有得到必要的隔离。例如，同时运行大规模性能测试的服务会影响彼此的结果。</p>
</li>
<li>
<p>不兼容的事件可能会生成到其他服务的输入事件流中。</p>
</li>
<li>
<p>事件流数据不可避免地变得过时，必须用较新的事件更新。</p>
</li>
<li>
<p>不能准确地表示在生产环境中出现的事件的范围。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image5.png" alt="image" width="47" height="44"></span>
就可用性而言，这种策略是最糟糕的选择，因为事件代理最终会成为混乱的事件流和损坏的数据的垃圾场。</p>
</div>
<div class="paragraph">
<p>在使用这种方案时，要做到与其他应用程序测试隔离是很难的，特别是当一个微服务的输出流是另一个微服务的输入流时。谨慎管理的数据流、严格的命名约定以及对写入事件流的限制有助于缓解这些缺点，但环境维护人员和用户需要勤勉工作并遵守纪律。</p>
</div>
</div>
<div class="sect2">
<h3 id="_15_7_3_使用生产环境进行测试"><a class="anchor" href="#_15_7_3_使用生产环境进行测试"></a>15.7.3 使用生产环境进行测试</h3>
<div class="paragraph">
<p>你也可以在生产环境中测试微服务。微服务可以运转起来、从输入事件流中消费、应用业务逻辑并产生输出。最常见的方法是让微服务使用自己指定的输出事件流和状态存储，这样就不会影响现有的生产系统。当一个微服务的旧版本与测试中的新版本同时运行时，这一点尤为重要。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">优点</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>你能完全访问生产事件。</p>
</li>
<li>
<p>其利用生产环境的安全模型来确保遵循正确的访问协议。</p>
</li>
<li>
<p>非常适用于应用程序的冒烟测试。</p>
</li>
<li>
<p>不需要维护单独的测试环境。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">缺点</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>有影响生产环境功能的风险，特别是当负载很高时。不适用于负载和性能测试。</p>
</li>
<li>
<p>必须仔细清除在测试期间创建的资源，比如事件流、消费者组、访问控制权限和状态存储。这类似于共享临时环境方案的要求。</p>
</li>
<li>
<p>需要工具支持来保证处于测试中的微服务和事件流与“真正的生产”微服务隔离，特别是当要执行长期测试时。这包括用于管理和部署微服务的资源，因为生产环境中的每个观察者都必须能够识别哪些服务是真正的生产服务，哪些服务是正在测试的服务。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_8_选择你的完全远程集成测试策略"><a class="anchor" href="#_15_8_选择你的完全远程集成测试策略"></a>15.8 选择你的完全远程集成测试策略</h2>
<div class="sectionbody">
<div class="paragraph">
<p>微服务模块化的好处在于，不必只选择一种方法来执行测试。可以根据需要使用任一方案，为其他项目切换到不同的方案，并随着需求的变化更新测试方法。对多集群事件代理的支持工具和事件复制功能的投资将在很大程度上决定你的测试方案。</p>
</div>
<div class="paragraph">
<p>如果你几乎没有支持性工具，那么很可能会采用一个单一且共享的测试事件代理，其中包含由各种团队和系统生成的事件流。你可能会看到可以用于测试的“好”事件流和后缀为“-testing-01”“-testing-02”“-testing-02-final”以及“-testing-02-final-v2”的事件流的混合。事件数据的可靠性、及时性以及 schema 的正确性都是不可保证的。部落知识虽然扮演着重要的角色，但它很难确保你的测试能充分反映服务在生产环境中的表现。此外，要让临时集群持续运行，并确保其支持性能测试、加载大数据集并提供永久的事件存储，所需的成本将很高。</p>
</div>
<div class="paragraph">
<p>通过对工具建设的适当投入，每个微服务可以建立自己的专用集群、用事件流填充集群、将一些生产数据复制到集群中并在与生产环境几乎相同的环境中运行测试。一旦测试完成，集群就可以被销毁，这样就消除了原本会留在共享集群中的测试制品。进入这一阶段的开销是巨大的，但是这个投入获得了多集群工作、冗余和灾难恢复的方案，而这些方案很难通过其他方式获得（更多详细信息，请参阅第 14 章）。</p>
</div>
<div class="paragraph">
<p>并不是说单一的共享测试集群本身就不好。谨慎地标记干净可靠的源代码流是很重要的，就像删除未使用的测试制品一样。具体且明确的职责可以让生产事件数据的团队把临时事件数据的可靠性管理好。团队还必须协调性能和负载测试，以确保它们不会影响彼此的结果。随着多集群和事件复制工具的不断改进，团队可以迁移到自己动态创建的测试集群中。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_9_小结"><a class="anchor" href="#_15_9_小结"></a>15.9 小结</h2>
<div class="sectionbody">
<div class="paragraph">
<p>事件驱动型微服务主要从事件流中获取其输入数据。可以通过多种方式创建和填充这些流，包括从生产环境中复制数据、管理特定的数据集以及基于 schema 自动生成事件。每种方法都有自己的优点和缺点，但它们都依赖于支持性工具来创建、填充和管理这些事件流。</p>
</div>
<div class="paragraph">
<p>建立测试微服务的环境应该是一项协作性工作。毫无疑问，你组织中的其他开发人员和工程师将受益于一个通用的测试平台，因此应该考虑投资于工具以简化测试过程。程序化的环境配置（包括事件流的填充）可以显著减少为每个被测微服务设置环境的开销。</p>
</div>
<div class="paragraph">
<p>当对工具的投入较低时，单一的共享测试环境是一种常用的策略。权衡的结果是在管理事件数据、确保有效性和澄清所有权方面增加了难度。一次性环境是更好的选择，因为它们为测试中的服务提供了隔离，并减少了由多租户问题引起的风险和缺点。这些方案往往需要在常用的支持工具上进行更多的投入，但从长远来看可以节省大量的时间和精力。另外一个好处是，使用程序化环境配置和事件复制工具可以更好地为组织做好灾难恢复的准备。</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="14.html">第 14 章 支持性工具</a></span>
  <span class="next"><a href="16.html">第 16 章 部署事件驱动型微服务</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
