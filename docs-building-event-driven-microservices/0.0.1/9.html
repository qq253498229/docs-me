<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 9 章 使用“函数即服务”的微服务 :: docs-me</title>
    <link rel="prev" href="8.html">
    <link rel="next" href="10.html">
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">docs-me</a>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs-building-event-driven-microservices" data-version="0.0.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="index.html">微服务与事件驱动架构</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="copyright.html">版权声明</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="o_reilly_media_inc_introduction.html">O&#8217;Reilly Media, Inc. 介绍</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="industry_evaluation.html">业界评论</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="introduction.html">前言</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="typesetting_convention.html">排版约定</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="o_reilly_online_learning_platform.html">O&#8217;Reilly在线学习平台（O&#8217;Reilly Online Learning）</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="contact_us.html">联系我们</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="acknowledgments.html">致谢</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="more_information.html">更多信息</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html">第 1 章 为什么用事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="1.html#_1_1_什么是事件驱动型微服务">1.1 什么是事件驱动型微服务</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_2_领域驱动设计和界限上下文">1.2 领域驱动设计和界限上下文</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_2_1_运用领域模型和界限上下文">1.2.1 运用领域模型和界限上下文</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_2_2_保持界限上下文与业务需求一致">1.2.2 保持界限上下文与业务需求一致</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_3_沟通结构">1.3 沟通结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_1_业务沟通结构">1.3.1 业务沟通结构</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_2_实现沟通结构">1.3.2 实现沟通结构</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_3_数据沟通结构">1.3.3 数据沟通结构</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_4_康威定律和沟通结构">1.3.4 康威定律和沟通结构</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_4_传统计算中的沟通结构">1.4 传统计算中的沟通结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_1_选项1创建一个新服务">1.4.1 选项1：创建一个新服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_2_选项2将它加入现有服务中">1.4.2 选项2：将它加入现有服务中</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_3_两种选项的利弊">1.4.3 两种选项的利弊</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_4_团队场景续">1.4.4 团队场景（续）</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_5_冲突的压力">1.4.5 冲突的压力</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_5_事件驱动的沟通结构">1.5 事件驱动的沟通结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_1_事件是通信的基础">1.5.1 事件是通信的基础</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_2_事件流提供了单一事实来源">1.5.2 事件流提供了单一事实来源</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_3_消费者执行自己的建模和查询">1.5.3 消费者执行自己的建模和查询</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_4_整个组织的数据沟通得到改善">1.5.4 整个组织的数据沟通得到改善</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_5_高可访问的数据利于业务变更">1.5.5 高可访问的数据利于业务变更</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_6_异步的事件驱动型微服务">1.6 异步的事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_使用事件驱动型微服务的示例团队">使用事件驱动型微服务的示例团队</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_7_同步式微服务">1.7 同步式微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_7_1_同步式微服务的缺点">1.7.1 同步式微服务的缺点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_7_2_同步式微服务的优点">1.7.2 同步式微服务的优点</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="1.html#_1_8_小结">1.8 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html">第 2 章 事件驱动型微服务基础</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_1_构建拓扑">2.1 构建拓扑</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_1_1_微服务拓扑">2.1.1 微服务拓扑</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_1_2_业务拓扑">2.1.2 业务拓扑</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_2_事件内容">2.2 事件内容</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_3_事件的结构">2.3 事件的结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_3_1_无键事件">2.3.1 无键事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_3_2_实体事件">2.3.2 实体事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_3_3_键控事件">2.3.3 键控事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_4_物化来自实体事件的状态">2.4 物化来自实体事件的状态</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_5_事件数据的定义和schema">2.5 事件数据的定义和schema</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_6_微服务单一写原则">2.6 微服务单一写原则</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_7_用事件代理赋能微服务">2.7 用事件代理赋能微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_7_1_事件存储和服务">2.7.1 事件存储和服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_7_2_需要考虑的其他因素">2.7.2 需要考虑的其他因素</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_8_事件代理与消息代理">2.8 事件代理与消息代理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_8_1_从不可变日志中消费">2.8.1 从不可变日志中消费</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_8_2_提供单一事实来源">2.8.2 提供单一事实来源</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_9_大规模管理微服务">2.9 大规模管理微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_9_1_将微服务放到容器内">2.9.1 将微服务放到容器内</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_9_2_将微服务放到虚拟机内">2.9.2 将微服务放到虚拟机内</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_9_3_管理容器和虚拟机">2.9.3 管理容器和虚拟机</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_10_缴纳微服务税">2.10 缴纳微服务税</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_11_小结">2.11 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="3.html">第 3 章 通信和数据契约</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="3.html#_3_1_事件驱动数据契约">3.1 事件驱动数据契约</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_1_使用显式schema作为契约">3.1.1 使用显式schema作为契约</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_2_schema定义的注释">3.1.2 schema定义的注释</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_3_全能的schema演化">3.1.3 全能的schema演化</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_4_有代码生成器支持">3.1.4 有代码生成器支持</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_5_破坏性的schema变更">3.1.5 破坏性的schema变更</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="3.html#_3_2_选择事件格式">3.2 选择事件格式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="3.html#_3_3_设计事件">3.3 设计事件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_1_只讲述事实">3.3.1 只讲述事实</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_2_每个流都使用单一事件定义">3.3.2 每个流都使用单一事件定义</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_3_使用最窄的数据类型">3.3.3 使用最窄的数据类型</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_4_保持事件的单一用途">3.3.4 保持事件的单一用途</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_5_最小化事件">3.3.5 最小化事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_6_让潜在的消费者参与事件设计">3.3.6 让潜在的消费者参与事件设计</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_7_避免将事件作为信号量或信号">3.3.7 避免将事件作为信号量或信号</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="3.html#_3_4_小结">3.4 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html">第 4 章 将事件驱动架构与现有系统集成</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_1_什么是数据解放">4.1 什么是数据解放</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_1_1_数据解放的折中方案">4.1.1 数据解放的折中方案</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_1_2_将被解放的数据转化成事件">4.1.2 将被解放的数据转化成事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_2_数据解放模式">4.2 数据解放模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_3_数据解放框架">4.3 数据解放框架</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_4_通过查询实施数据解放">4.4 通过查询实施数据解放</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_1_批量加载">4.4.1 批量加载</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_2_增量时间戳加载">4.4.2 增量时间戳加载</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_3_自增id加载">4.4.3 自增ID加载</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_4_自定义查询">4.4.4 自定义查询</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_5_增量更新">4.4.5 增量更新</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_6_基于查询更新的优点">4.4.6 基于查询更新的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_7_基于查询更新的缺点">4.4.7 基于查询更新的缺点</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_5_使用变更数据捕获日志解放数据">4.5 使用变更数据捕获日志解放数据</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_5_1_使用数据存储日志的优点">4.5.1 使用数据存储日志的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_5_2_使用数据库日志的缺点">4.5.2 使用数据库日志的缺点</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_6_使用发件箱表解放数据">4.6 使用发件箱表解放数据</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_1_性能考虑">4.6.1 性能考虑</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_2_隔离内部数据模型">4.6.2 隔离内部数据模型</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_3_确保schema兼容性">4.6.3 确保schema兼容性</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_4_使用触发器捕获变更数据">4.6.4 使用触发器捕获变更数据</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_7_对处于捕获的数据集做数据定义变更">4.7 对处于捕获的数据集做数据定义变更</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_7_1_为查询和cdc日志模式处理事后数据定义变更">4.7.1 为查询和CDC日志模式处理事后数据定义变更</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_7_2_为变更数据表捕获模式处理数据定义变更">4.7.2 为变更数据表捕获模式处理数据定义变更</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_8_将事件数据落地到数据存储">4.8 将事件数据落地到数据存储</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_9_数据落地和获取对业务的影响">4.9 数据落地和获取对业务的影响</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_10_小结">4.10 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html">第 5 章 事件驱动处理基础</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_1_构建无状态拓扑">5.1 构建无状态拓扑</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_1_1_转换">5.1.1 转换</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_1_2_分流与合流">5.1.2 分流与合流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_2_对事件流再分区">5.2 对事件流再分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_示例对一个事件流再分区">示例：对一个事件流再分区</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_3_对事件流协同分区">5.3 对事件流协同分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_示例对一个事件流进行协同分区">示例：对一个事件流进行协同分区</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_4_给消费者实例分配分区">5.4 给消费者实例分配分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_4_1_使用分区分配器分配分区">5.4.1 使用分区分配器分配分区</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_4_2_分配协同分区">5.4.2 分配协同分区</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_4_3_分区分配策略">5.4.3 分区分配策略</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="5.html#_5_5_从无状态处理实例故障中恢复">5.5 从无状态处理实例故障中恢复</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="5.html#_5_6_小结">5.6 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html">第 6 章 具有确定性的流处理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_1_事件驱动工作流的确定性">6.1 事件驱动工作流的确定性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_2_时间戳">6.2 时间戳</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_2_1_同步分布式时间戳">6.2.1 同步分布式时间戳</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_2_2_处理带时间戳的事件">6.2.2 处理带时间戳的事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_3_事件调度和确定性处理">6.3 事件调度和确定性处理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_1_自定义事件调度器">6.3.1 自定义事件调度器</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_2_基于事件时间处理时间和摄取时间进行处理">6.3.2 基于事件时间、处理时间和摄取时间进行处理</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_3_消费者提取时间戳">6.3.3 消费者提取时间戳</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_4_对外部系统的请求响应调用">6.3.4 对外部系统的“请求–响应”调用</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_4_水位">6.4 水位</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_并行处理中的水位">并行处理中的水位</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_5_流时间">6.5 流时间</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_并行处理中的流时间">并行处理中的流时间</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_6_乱序事件和迟到事件">6.6 乱序事件和迟到事件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_6_1_使用水位和流时间的迟到事件">6.6.1 使用水位和流时间的迟到事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_6_2_乱序事件的原因和影响">6.6.2 乱序事件的原因和影响</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_6_3_时间敏感的函数和窗口化">6.6.3 时间敏感的函数和窗口化</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_7_处理迟到事件">6.7 处理迟到事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_8_再处理与近实时处理">6.8 再处理与近实时处理</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_9_间歇性故障和迟到事件">6.9 间歇性故障和迟到事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_10_生产者事件代理的连接性问题">6.10 生产者/事件代理的连接性问题</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_11_小结与延展阅读">6.11 小结与延展阅读</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html">第 7 章 有状态的流</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="7.html#_7_1_状态存储与从事件流中物化状态">7.1 状态存储与从事件流中物化状态</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="7.html#_7_2_记录状态到变更日志事件流">7.2 记录状态到变更日志事件流</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_3_将状态物化至内部状态存储">7.3 将状态物化至内部状态存储</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_1_物化全局状态">7.3.1 物化全局状态</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_2_使用内部状态的优点">7.3.2 使用内部状态的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_3_使用内部状态的缺点">7.3.3 使用内部状态的缺点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_4_内部状态的伸缩和恢复">7.3.4 内部状态的伸缩和恢复</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_4_将状态物化至外部状态存储">7.4 将状态物化至外部状态存储</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_4_1_外部状态的优点">7.4.1 外部状态的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_4_2_外部状态的缺点">7.4.2 外部状态的缺点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_4_3_外部状态存储的伸缩和恢复">7.4.3 外部状态存储的伸缩和恢复</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_5_重建与迁移状态存储">7.5 重建与迁移状态存储</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_5_1_重建">7.5.1 重建</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_5_2_迁移">7.5.2 迁移</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_6_事务与有效一次处理">7.6 事务与有效一次处理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_6_1_示例库存计算服务">7.6.1 示例：库存计算服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_6_2_使用客户端代理事务的有效一次处理">7.6.2 使用“客户端–代理”事务的有效一次处理</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_6_3_没有客户端代理事务的有效一次处理">7.6.3 没有“客户端–代理”事务的有效一次处理</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="7.html#_7_7_小结">7.7 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html">第 8 章 用微服务构建工作流</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html#_8_1_编排模式">8.1 编排模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_1_1_一个简单的事件驱动编排示例">8.1.1 一个简单的事件驱动编排示例</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_1_2_创建和修改编排的工作流">8.1.2 创建和修改编排的工作流</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_1_3_监控编排的工作流">8.1.3 监控编排的工作流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html#_8_2_编制模式">8.2 编制模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_1_一个简单的事件驱动编制模式例子">8.2.1 一个简单的事件驱动编制模式例子</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_2_一个简单的直接调用的编制模式例子">8.2.2 一个简单的直接调用的编制模式例子</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_3_对比事件驱动编制模式和直接调用的编制模式">8.2.3 对比事件驱动编制模式和直接调用的编制模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_4_创建和修改编制工作流">8.2.4 创建和修改编制工作流</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_5_监控编制工作流">8.2.5 监控编制工作流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html#_8_3_分布式事务">8.3 分布式事务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_3_1_编排型事务saga模式">8.3.1 编排型事务：saga模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_3_2_编制型事务">8.3.2 编制型事务</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="8.html#_8_4_补偿工作流">8.4 补偿工作流</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="8.html#_8_5_小结">8.5 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="9.html">第 9 章 使用“函数即服务”的微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#_9_1_设计基于函数的微服务解决方案">9.1 设计基于函数的微服务解决方案</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_1_1_确保界限上下文的严格的成员关系">9.1.1 确保界限上下文的严格的成员关系</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_1_2_只在完成处理之后提交偏移量">9.1.2 只在完成处理之后提交偏移量</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_1_3_少即是多">9.1.3 少即是多</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_9_2_选择faas供应商">9.2 选择FaaS供应商</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_9_3_在函数之外构建微服务">9.3 在函数之外构建微服务</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_9_4_冷启动和热启动">9.4 冷启动和热启动</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#_9_5_用触发器启动函数">9.5 用触发器启动函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_5_1_基于新事件触发事件流监听器">9.5.1 基于新事件触发：事件流监听器</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_5_2_基于消费者组的滞后度触发">9.5.2 基于消费者组的滞后度触发</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_5_3_按调度表触发">9.5.3 按调度表触发</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_5_4_使用网络钩子触发">9.5.4 使用网络钩子触发</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_5_5_触发资源事件">9.5.5 触发资源事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_9_6_用函数执行业务工作">9.6 用函数执行业务工作</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_9_7_维持状态">9.7 维持状态</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#_9_8_调用其他函数的函数">9.8 调用其他函数的函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_8_1_事件驱动通信模式">9.8.1 事件驱动通信模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_8_2_直接调用模式">9.8.2 直接调用模式</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_9_9_终止和关闭">9.9 终止和关闭</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#_9_10_调整函数">9.10 调整函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_10_1_分配足够的资源">9.10.1 分配足够的资源</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_9_10_2_批量事件处理的参数">9.10.2 批量事件处理的参数</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_9_11_faas的伸缩方案">9.11 FaaS的伸缩方案</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_9_12_小结">9.12 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="10.html">第 10 章 基础的生产者和消费者微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="10.html#_10_1_bpc的适用场合">10.1 BPC的适用场合</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_1_集成现有遗留系统">10.1.1 集成现有遗留系统</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_2_不依赖于事件顺序的有状态的业务逻辑">10.1.2 不依赖于事件顺序的有状态的业务逻辑</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_3_当数据层完成大部分工作时">10.1.3 当数据层完成大部分工作时</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_4_处理层和数据层独立伸缩">10.1.4 处理层和数据层独立伸缩</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="10.html#_10_2_具有外部流处理的混合bpc应用程序">10.2 具有外部流处理的混合BPC应用程序</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_示例使用外部流处理框架来联结事件流">示例：使用外部流处理框架来联结事件流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="10.html#_10_3_小结">10.3 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="11.html">第 11 章 使用重量级框架的微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_1_重量级框架的简单历史">11.1 重量级框架的简单历史</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_2_重量级框架的内部运作">11.2 重量级框架的内部运作</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_3_优点和局限性">11.3 优点和局限性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="11.html#_11_4_集群搭建方案和执行模式">11.4 集群搭建方案和执行模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_4_1_使用托管服务">11.4.1 使用托管服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_4_2_构建自己的完整集群">11.4.2 构建自己的完整集群</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_4_3_使用cms集成来创建集群">11.4.3 使用CMS集成来创建集群</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="11.html#_11_5_应用程序提交模式">11.5 应用程序提交模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_5_1_驱动器模式">11.5.1 驱动器模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_5_2_集群模式">11.5.2 集群</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_6_处理状态和使用检查点">11.6 处理状态和使用检查点</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="11.html#_11_7_伸缩应用程序和处理事件流分区">11.7 伸缩应用程序和处理事件流分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_7_1_伸缩运行中的应用程序">11.7.1 伸缩运行中的应用程序</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_7_2_通过重启伸缩应用程序">11.7.2 通过重启伸缩应用程序</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="11.html#_11_7_3_自动伸缩应用程序">11.7.3 自动伸缩应用程序</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_8_从故障中恢复">11.8 从故障中恢复</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_9_考虑多租户问题">11.9 考虑多租户问题</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_10_语言和语法">11.10 语言和语法</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_11_选择一个框架">11.11 选择一个框架</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_12_示例点击和观看的会话窗口">11.12 示例：点击和观看的会话窗口</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="11.html#_11_13_小结">11.13 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="12.html">第 12 章 使用轻量级框架的微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_1_优点和局限性">12.1 优点和局限性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_2_轻量级处理">12.2 轻量级处理</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_3_处理状态和使用变更日志">12.3 处理状态和使用变更日志</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="12.html#_12_4_伸缩和故障恢复">12.4 伸缩和故障恢复</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_4_1_事件洗牌">12.4.1 事件洗牌</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_4_2_状态分配">12.4.2 状态分配</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_4_3_状态复制和热副本">12.4.3 状态复制和热副本</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="12.html#_12_5_选择一个轻量级框架">12.5 选择一个轻量级框架</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_5_1_apache_kafka_streams">12.5.1 Apache Kafka Streams</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_5_2_apache_samza嵌入模式">12.5.2 Apache Samza：嵌入模式</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_6_语言和语法">12.6 语言和语法</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_7_流表表联结增强模式">12.7 流–表–表联结：增强模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_8_小结">12.8 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html">第 13 章 集成事件驱动型和“请求–响应”型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_1_处理外部事件">13.1 处理外部事件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_1_1_自动生成的事件">13.1.1 自动生成的事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_1_2_由响应生成的事件">13.1.2 由响应生成的事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_2_处理自动生成的分析事件">13.2 处理自动生成的分析事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_3_集成第三方请求响应api">13.3 集成第三方“请求–响应”API</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_4_处理并提供有状态的数据">13.4 处理并提供有状态的数据</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_4_1_实时请求内部状态存储">13.4.1 实时请求内部状态存储</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_4_2_实时请求外部状态存储">13.4.2 实时请求外部状态存储</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_5_在事件驱动的工作流中处理请求">13.5 在事件驱动的工作流中处理请求</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_处理用户界面事件">处理用户界面事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_6_请求响应应用程序中的微前端">13.6 “请求–响应”应用程序中的微前端</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_7_微前端的优点">13.7 微前端的优点</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_7_1_基于组合的微服务">13.7.1 基于组合的微服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_7_2_容易与业务需求对齐">13.7.2 容易与业务需求对齐</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_8_微前端的缺点">13.8 微前端的缺点</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_8_1_可能不一致的ui元素和样式">13.8.1 可能不一致的UI元素和样式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_8_2_不同的微前端性能">13.8.2 不同的微前端性能</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_8_3_示例体验搜索与评论应用程序">13.8.3 示例：体验搜索与评论应用</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_9_小结">13.9 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="14.html">第 14 章 支持性工具</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_1_微服务团队分配系统">14.1 微服务–团队分配系统</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_2_事件流的创建和修改">14.2 事件流的创建和修改</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_3_事件流元数据标记">14.3 事件流元数据标记</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_4_限额">14.4 限额</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_5_schema注册表">14.5 schema注册表</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_6_schema创建和修改通知">14.6 schema创建和修改通知</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_7_偏移量管理">14.7 偏移量管理</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_8_事件流的权限和访问控制列表">14.8 事件流的权限和访问控制列表</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_9_状态管理和应用程序重置">14.9 状态管理和应用程序重置</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_10_消费者偏移量滞后度监控">14.10 消费者偏移量滞后度</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_11_流水线型的微服务创建流程">14.11 流水线型的微服务创建流程</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_12_容器管理控制">14.12 容器管理控制</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="14.html#_14_13_集群创建和管理">14.13 集群创建和管理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_1_事件代理的程序化创建">14.13.1 事件代理的程序化创建</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_2_计算资源的程序化创建">14.13.2 计算资源的程序化创建</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_3_跨集群事件数据复制">14.13.3 跨集群事件数据复制</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_4_工具的程序化创建">14.13.4 工具的程序化创建</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="14.html#_14_14_依赖跟踪和拓扑可视化">14.14 依赖跟踪和拓扑可视化</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_拓扑示例">拓扑示例</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_15_小结">14.15 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="15.html">第 15 章 测试事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_1_通用测试原则">15.1 通用测试原则</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="15.html#_15_2_单元测试拓扑函数">15.2 单元测试拓扑函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_2_1_无状态的函数">15.2.1 无状态的函数</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_2_2_有状态的函数">15.2.2 有状态的函数</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_3_测试拓扑">15.3 测试拓扑</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_4_测试schema演化和兼容性">15.4 测试schema演化和兼容性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_5_事件驱动型微服务的集成测试">15.5 事件驱动型微服务的集成测试</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="15.html#_15_6_本地集成测试">15.6 本地集成测试</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_6_1_在测试代码的运行时内创建临时环境">15.6.1 在测试代码的运行时内创建临时环境</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_6_2_在测试代码外部创建临时环境">15.6.2 在测试代码外部创建临时环境</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_6_3_使用mocking和模拟器方法集成托管服务">15.6.3 使用mocking和模拟器方法集成托管</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_6_4_集成没有本地支持的远程服务">15.6.4 集成没有本地支持的远程服务</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="15.html#_15_7_完全远程集成测试">15.7 完全远程集成测试</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_7_1_程序化创建临时集成测试环境">15.7.1 程序化创建临时集成测试环境</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_7_2_使用共享环境进行测试">15.7.2 使用共享环境进行测试</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_7_3_使用生产环境进行测试">15.7.3 使用生产环境进行测试</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_8_选择你的完全远程集成测试策略">15.8 选择你的完全远程集成测试策略</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_9_小结">15.9 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="16.html">第 16 章 部署事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_1_微服务部署的原则">16.1 微服务部署的原则</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="16.html#_16_2_微服务部署的架构组件">16.2 微服务部署的架构组件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_2_1_持续集成系统持续交付系统和持续部署系统">16.2.1 持续集成系统、持续交付系统和持续部署</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_2_2_cms和商业硬件">16.2.2 CMS和商业硬件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_3_基本的全站式部署模式">16.3 基本的全站式部署模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_4_滚动更新模式">16.4 滚动更新模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="16.html#_16_5_破坏性的schema变更模式">16.5 破坏性的schema变更模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_5_1_通过两个事件流达到最终迁移">16.5.1 通过两个事件流达到最终迁移</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_5_2_同步迁移到新事件流">16.5.2 同步迁移到新事件流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_6_蓝绿部署模式">16.6 蓝绿部署模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_7_小结">16.7 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="17.html">第 17 章 结论</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_1_通信层">17.1 通信层</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_2_业务领域和界限上下文">17.2 业务领域和界限上下文</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_3_可共享的工具和基础设施">17.3 可共享的工具和基础设施</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_4_结构化事件">17.4 结构化事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_5_数据解放和单一事实来源">17.5 数据解放和单一事实来源</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_6_微服务">17.6 微服务</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_7_微服务实现方案">17.7 微服务实现方案</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_8_测试">17.8 测试</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_9_部署">17.9 部署</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_10_结语">17.10 结语</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="about_author.html">关于作者</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="about_cover.html">关于封面</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">微服务与事件驱动架构</span>
    <span class="version">0.0.1</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../docs-config/0.0.1/index.html">docs-config</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-config/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-steam-electron/0.0.1/index.html">docs-steam-electron</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-steam-electron/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-xiuxian/0.0.1/index.html">docs-xiuxian</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-xiuxian/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-es-java/7.16.0/introduction.html">ES Java API Client</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-es-java/7.16.0/introduction.html">7.16.0</a>
        </li>
        <li class="version">
          <a href="../../docs-es-java/6.8.0/preface.html">6.8.0</a>
        </li>
        <li class="version">
          <a href="../../docs-es-java/6.2.2/1Preface/readme.html">6.2.2</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-greenworks-js/0.0.1/index.html">Greenworks-JS 文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-greenworks-js/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-rust-libp2p/0.0.1/index.html">libp2p入门</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-rust-libp2p/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-neutralino-api/0.0.1/index.html">NeutralinoJS 文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-neutralino-api/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-antora-oauth2.1/0.0.1/index.html">OAuth 2.1 授权框架</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-antora-oauth2.1/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-pd2/0.0.1/index.html">PD2记录</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-pd2/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-peerjs/0.0.1/index.html">PEER JS</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-peerjs/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-actuator/3.3.3/index.html">Spring Boot Actuator</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-actuator/3.3.3/index.html">3.3.3</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-oauth2/0.0.1/index.html">Spring Boot OAuth2</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-oauth2/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-steamworks-rs/0.11.0/index.html">Steamworks for Rust</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-steamworks-rs/0.11.0/index.html">0.11.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-tauri/v1/index.html">Tauri API 文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-tauri/v1/index.html">v1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-testing-angular/中文/start.html">Testing Angular</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-testing-angular/中文/start.html">中文</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-me/0.0.1/index.html">个人记录</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-me/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-taiwu/0.0.1/index.html">太吾绘卷</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-taiwu/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-palworld/0.0.1/index.html">幻兽帕鲁笔记</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-palworld/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="index.html">微服务与事件驱动架构</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-hunter/0.0.1/index.html">猎人-荒野的呼唤</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-hunter/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-logitech/v8.45/index.html">罗技鼠标宏文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-logitech/v8.45/index.html">v8.45</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-milk/0.0.1/index.html">银河奶牛</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-milk/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../docs-me/0.0.1/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">微服务与事件驱动架构</a></li>
    <li><a href="9.html">第 9 章 使用“函数即服务”的微服务</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="https://github.com/qq253498229/docs-building-event-driven-microservices/edit/master/modules/ROOT/pages/9.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="目录" data-levels="3">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">第 9 章 使用“函数即服务”的微服务</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>“ 函数即服务” （function-as-a-service ，FaaS ）是近些年越来越流行的一种“ 无服务端”（serverless）解决方案。FaaS 解决方案使个人能够构建、管理、部署和扩展应用程序功能，而无须管理基础设施开销。作为实现简单到中等复杂解决方案的一种手段，它们可以在事件驱动系统中提供重要的价值。</p>
</div>
<div class="paragraph">
<p>函数是当某些触发条件发生时执行的一串代码。函数启动、运行直到完成，然后在工作完成后终止。FaaS解决方案可以轻松地根据负载上下调整函数执行的数量，密切跟踪高度可变的负载。</p>
</div>
<div class="paragraph">
<p>把 FaaS 解决方案看作会定期失败的基础消费者/生产者实现可能会对你成功实施该方案有所帮助。函数在经过一段预先设定的时间后会终止，并且所有与之相关的连接和状态也会消失。当你设计函数时要记住这一点。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_1_设计基于函数的微服务解决方案"><a class="anchor" href="#_9_1_设计基于函数的微服务解决方案"></a>9.1 设计基于函数的微服务解决方案</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FaaS 解决方案包含了许多不同的函数，它们的操作总和构成了业务界限上下文的解决方案。创建基于函数的解决方案的方法有很多，远超过本章所能涵盖的内容，但是有一些通用的设计原则可以帮助你完成这个过程。</p>
</div>
<div class="sect2">
<h3 id="_9_1_1_确保界限上下文的严格的成员关系"><a class="anchor" href="#_9_1_1_确保界限上下文的严格的成员关系"></a>9.1.1 确保界限上下文的严格的成员关系</h3>
<div class="paragraph">
<p>构成解决方案的函数及内部事件流必须严格从属于某个界限上下文，这样函数和数据的所有者就相当明确了。组织在大规模实施微服务解决方案时，通常会围绕函数、服务和事件流出现归属问题。虽然许多微服务解决方案会 1∶1 地映射到界限上下文，但 n∶1 的映射并不少见，因为许多函数可能用于同一个界限上下文中。确定哪个函数属于哪个界限上下文是很重要的，因为函数的高度颗粒化可能会模糊这些界限。</p>
</div>
<div class="paragraph">
<p>维护使用函数方案的界限上下文的一些实践方法包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保数据存储是私有的，与外部上下文隔离；</p>
</li>
<li>
<p>当要耦合其他上下文时，使用标准的“请求–响应”或事件驱动接口；</p>
</li>
<li>
<p>围绕“哪些函数属于哪些界限上下文”（函数对产品 1∶1 地映射）维护严格的元数据；</p>
</li>
<li>
<p>在映射到界限上下文的代码仓库中维护函数代码。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_9_1_2_只在完成处理之后提交偏移量"><a class="anchor" href="#_9_1_2_只在完成处理之后提交偏移量"></a>9.1.2 只在完成处理之后提交偏移量</h3>
<div class="paragraph">
<p>偏移量会在函数启动时或函数完成处理时发生提交。对于给定的一个事件或一批事件，只在处理完成之后提交偏移量是 FaaS 的最佳实践。理解如何在基于函数的特定解决方案中处理偏移量很重要，下面来看看每种方法的含义。</p>
</div>
<div class="paragraph">
<p>1. 当函数启动时</p>
</div>
<div class="paragraph">
<p>一旦要处理的一批事件已经传递到函数，就可以提交偏移量了。这种简单的方法被用于许多 FaaS 框架中，这些框架依赖于自身的重试机制和告警来减少重复的失败处理。在编排模式中，调用其他函数的函数通常会采用该策略，因为它极大地简化了对事件处理情况的跟踪。</p>
</div>
<div class="paragraph">
<p>2. 当函数完成处理时</p>
</div>
<div class="paragraph">
<p>函数完成处理后提交偏移量的方法与其他微服务实现提交偏移量的方法一致，无论它们是基于基础的生产者/消费者还是流处理框架。这个策略提供了最强的事件被“至少一次处理”的保证，并且与非FaaS 解决方案的偏移量管理策略是一样的。</p>
</div>
<div class="paragraph">
<p>但是，在处理完成之前提交偏移量可能会有问题。如果函数无法成功地处理事件，并且多次重试失败，那么数据可能会丢失。通常会将事件放入一个“死信”队列或简单地将其抛弃。许多基于函数的微服务对数据丢失并不敏感，而那些敏感的微服务不应该使用该策略。</p>
</div>
</div>
<div class="sect2">
<h3 id="_9_1_3_少即是多"><a class="anchor" href="#_9_1_3_少即是多"></a>9.1.3 少即是多</h3>
<div class="paragraph">
<p>FaaS 框架的一个经常被推崇的特性是，它们可以很容易地编写一个函数并在多个服务中复用它。然而，遵循这种方法可能会导致一个高度分散的解决方案，这使得很难准确地辨别在界限上下文中发生了什么。此外，一个函数的所有权会变得模糊，并且当变更函数时会搞不清楚对其他微服务有什么副作用。虽然函数的版本管理有助于解决这个问题，但是当有多个产品要维护和升级不同的函数版本时，仍然会产生冲突。</p>
</div>
<div class="paragraph">
<p>FaaS 解决方案可以组合多个函数来解决界限上下文的业务需求，虽然这不是一个罕见或不好的做法，但较好的经验法则是，少量函数比许多细粒度函数更好。只对一个函数进行测试、调试和管理比对多个函数做同样的事情容易得多。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_2_选择faas供应商"><a class="anchor" href="#_9_2_选择faas供应商"></a>9.2 选择FaaS供应商</h2>
<div class="sectionbody">
<div class="paragraph">
<p>与事件代理和 CMS 一样，FaaS 框架可以选择免费的开源解决方案或者付费的第三方云供应商。使用自己的私有 CMS 进行微服务操作的组织，也可以从私有的 FaaS 解决方案中受益。有许多免费开源的选项，比如 OpenWhisk、OpenFaaS 和 Kubeless，它们可以使用已有的容器管理服务。Apache Pulsar 有自己内置的 FaaS 解决方案，可以与其事件代理配合运行。通过利用公共资源调配框架，你的 FaaS 解决方案可以与微服务解决方案保持一致。</p>
</div>
<div class="paragraph">
<p>Amazon Web Services（AWS）、Google Cloud Platform（GCP）和 Microsoft Azure 等第三方服务供应商也有自己的专有 FaaS 框架，每个框架都提供了吸引人的特性和功能，但仍然与其提供的专有事件代理紧密集成。这是一个严重的问题，因为当前这 3 家供应商都将其事件代理内的保留期限制为 7 天。云供应商和开源事件代理之间的集成方案虽然存在（比如 Kafka Connect），但可能需要额外的工作来搭建和管理。也就是说，如果你的组织已经使用了 AWS、GCP 和 Azure 的服务，那么开启这个体验的开销就很小。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_3_在函数之外构建微服务"><a class="anchor" href="#_9_3_在函数之外构建微服务"></a>9.3 在函数之外构建微服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>无论你使用什么 FaaS 框架或事件代理，当采用基于函数的解决方案时，就必须考虑 4 个主要元素。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>函数</p>
</li>
<li>
<p>输入事件流</p>
</li>
<li>
<p>触发逻辑</p>
</li>
<li>
<p>带元数据的错误处理和伸缩策略</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>FaaS 实现的第一个组件是函数本身。函数可以用 FaaS 框架所支持的任何代码来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public int myfunction(Event[] events, Context context) {
    println ("hello world!");
    return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>events 参数包含了要处理的事件数组，每个事件包含 key、value、timestamp、offset 和 partition_id等字段。context 参数包含了关于函数及其上下文的信息，比如名字、事件流 ID 和函数的剩余寿命。</p>
</div>
<div class="paragraph">
<p>接下来，需要为函数写一些触发逻辑。下一节会更详细地介绍这方面的内容，但是现在，记住，一旦有新的事件到达函数订阅的其中一个事件流，就会触发函数执行。触发逻辑常常通过“函数触发映射表”与函数相关联，函数触发映射表通常隐藏在 FaaS 框架的幕后。以下是一个示例（参见表 9-1）。</p>
</div>
<div class="paragraph">
<p>表 9-1：函数触发映射表</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">函数</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事件流</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">触发器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">策略和元数据</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">myFunction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">myInputStream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">onNewEvent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&#8230;&#8203;&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可以看到，函数 myFunction 在新事件发布到 myInputStream 时被触发。你还会注意到，有一个名为“策略和元数据”的列，它有点儿包罗万象，包括以下配置。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>消费者组</p>
</li>
<li>
<p>消费者属性，比如批量大小和批量窗口</p>
</li>
<li>
<p>重试和错误处理策略</p>
</li>
<li>
<p>伸缩策略</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一旦建立了触发器、元数据和策略，函数就会准备处理到来的事件。当新的事件到达输入事件流时，FaaS框架会启动函数，向其传递一批事件，然后函数开始进行处理。一旦处理完成，函数会终止操作并等待更多事件到来。这是一个典型的事件流监听器模式的实现，下一节会进行更详细的介绍。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
跟其他非 FaaS 微服务一样，每个基于函数的微服务实现都必须有自己独立的消费者组。</p>
</div>
<div class="paragraph">
<p>现在请记住，这只是成功触发和操作函数所需组件的逻辑表示。FaaS 框架的函数编码要求、函数管理和触发机制会根据供应商和实现的不同而变化，所以请务必参考 FaaS 框架的文档。</p>
</div>
<div class="paragraph">
<p>触发机制、事件消费、消费者偏移量、嵌套函数、故障以及至少一次事件处理之间也存在一些复杂的相互作用。这些是本章剩余内容要讨论的主题。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_4_冷启动和热启动"><a class="anchor" href="#_9_4_冷启动和热启动"></a>9.4 冷启动和热启动</h2>
<div class="sectionbody">
<div class="paragraph">
<p>冷启动是函数在第一次启动或在足够长的不活动时间后启动时的默认状态。此时容器必须启动并加载代码、创建事件代理连接，并且建立所有跟外部资源的客户端连接。一旦所有元素都准备就绪，函数就处于一个“热”的状态并准备处理事件。“热”函数开始处理事件，在到期或完成处理时暂停并进入挂起状态。</p>
</div>
<div class="paragraph">
<p>大部分 FaaS 框架想要尽可能重用终止处理的函数。在许多情况下，处理稳定的事件流的函数会遇到超时到期并短暂终止，稍后由触发机制再次触发。挂起的实例可以简单地重用，如果与事件代理和任何状态存储的连接在此期间没有过期，则可以立即恢复处理。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_5_用触发器启动函数"><a class="anchor" href="#_9_5_用触发器启动函数"></a>9.5 用触发器启动函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>触发器用于通知函数启动并开始处理。如接下来的内容所述，不同的 FaaS 框架支持的触发器会有所不同，但通常都有相同的分类。现在来看看有哪些信号可以用来启动函数，以及分别在什么时候可能需要使用它们。</p>
</div>
<div class="sect2">
<h3 id="_9_5_1_基于新事件触发事件流监听器"><a class="anchor" href="#_9_5_1_基于新事件触发事件流监听器"></a>9.5.1 基于新事件触发：事件流监听器</h3>
<div class="paragraph">
<p>当事件被发布到事件流中时可以触发函数。事件流监听触发器用预先定义好的消费者屏蔽了事件消费逻辑，这减少了开发者必须编写的代码量。事件以事件数组的形式直接发送给函数，它们会按照事件流中的顺序排列，如果消费来自队列的事件则是一串无序的事件。你可以创建事件流到函数的多个映射关系，比如一个函数可以从多个不同的流消费事件。</p>
</div>
<div class="paragraph">
<p>来自谷歌、微软和亚马逊的 FaaS 解决方案为其专用事件代理提供了此类触发器，但目前不支持直接从开源代理触发。此方法通常的结构如图 9-1 所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image182.png" alt="image182">
</div>
<div class="title">Figure 1. 图 9-1：集成了事件流监听器的 FaaS 框架</div>
</div>
<div class="paragraph">
<p>相反，开源解决方案（如 OpenFaaS、Kubeless、Nuclio 等）为各种事件代理（如 Kafka、Pulsar 和NATS）提供了各种触发插件。例如，Apache Kafka Connect 允许你触发第三方 FaaS 框架的函数。由于Kafka Connect 运行在 FaaS 框架之外，因此最终只会作为一个事件流监听器的角色而存在，如图 9-2所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image183.png" alt="image183">
</div>
<div class="title">Figure 2. 图 9-2：Kafka Connect 提供的外部事件流监听器应用程序</div>
</div>
<div class="paragraph">
<p>虽然前面的例子中没有展示，但是也可以将函数结果输出到它们自己的事件流中，不只是为了输出数据，也是为了跟踪函数是否成功调用。</p>
</div>
<div class="paragraph">
<p>同步触发器在函数处理完一批事件之后才会发出下一批事件。这对于保证处理顺序是相当重要的，并且受限于被处理的事件流的并行度。相反，异步触发可以发送多个事件到多个函数，每个函数在完成处理之后返回。但是，这将无法保证处理的顺序，并且只能用于处理顺序对业务逻辑不重要的场景。</p>
</div>
<div class="paragraph">
<p>在流监听触发器中，批量大小和批量窗口是需要考虑的两个重要属性。批量大小表明了发送给函数处理的事件的最大数量，批量窗口表明了等待额外事件的最长时间，而不是立即触发函数。这两个参数都用于确保在批记录中分配启动函数的开销，以降低启动成本。</p>
</div>
<div class="paragraph">
<p>由流监听触发器函数执行的示例代码如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public int myEventfunction(Event[] events, Context context) {
    for(Event event: events)
    try {
        println (event.key + ", " + event.value);
    } catch (Exception e) {
        println ("error printing " + event.toString);
    }
    //向FaaS框架表明批处理已经完成
    context.success();

    return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
与容器化的微服务类似，事件流监听器模式的触发器可以配置成从流的最新的偏移量、最早的偏移量或这两者之间的任何位置开始处理事件。</p>
</div>
</div>
<div class="sect2">
<h3 id="_9_5_2_基于消费者组的滞后度触发"><a class="anchor" href="#_9_5_2_基于消费者组的滞后度触发"></a>9.5.2 基于消费者组的滞后度触发</h3>
<div class="paragraph">
<p>消费者组的滞后度量是另一种触发函数的方法。可以通过定期轮询每个应用程序的消费者组的偏移量并计算当前消费者偏移量和流的头部偏移量的差值来消除滞后度（参见 14.10 节获取更多关于滞后度监控的内容）。虽然与流监听触发器类似，但滞后度监控也可以用于非 FaaS 微服务的扩缩容。</p>
</div>
<div class="paragraph">
<p>滞后度监控通常涉及计算并向所选择的监控框架上报滞后度量值。然后监控框架可以调用 FaaS 框架以通知其启动注册在该事件流上的函数。高滞后度值表明要启动多个函数实例来更快速地处理负载，而低滞后度值只需要一个函数实例来处理积压。可以一个微服务接一个微服务地定制滞后量和函数启动之间的关系，确保其符合 SLA。</p>
</div>
<div class="paragraph">
<p>与之前提到的事件流监听触发器最大的不同是，用滞后度触发的函数直到启动之后才开始消费事件。滞后度触发器启动的函数有更广的职责范围，包括建立与事件代理的客户端连接、消费事件和提交偏移量更新。这使得滞后度触发的函数与基础的生产者 / 消费者模式更为相似，尽管其使用寿命有限。下面的示例代码展示了这个工作流。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public int myLagConsumerfunction(Context context) {
    String consumerGroup = context.consumerGroup;
    String streamName = context.streamName;

    EventBrokerClient client = new EventBrokerClient(consumerGroup, ...);

    Event[] events = client.consumeBatch(streamName, ...);

    for(Event event: events) {
        //执行事件处理操作
        doWork(event);
    }
    //将偏移量提交回事件代理
    client.commitOffsets();

    //向FaaS框架表明函数已成功执行
    context.success();

    //返回，让滞后度触发系统知道函数已成功执行
    return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>消费者组和流名字作为上下文中的参数传递给了函数。创建客户端、消费并处理事件，然后向事件代理提交偏移量。函数将一个 success 结果报告给 FaaS 框架，然后返回。</p>
</div>
<div class="paragraph">
<p>如果该函数频繁地由滞后度监控器触发，则从上一次迭代开始到现在，它很有可能仍然是“热”的，而此时连接到事件代理客户端的开销可能就不是关键问题。当然，这依赖于客户端使用的超时时间和事件代理配置。对于较长时间不活动的情况，消费者组再平衡和客户端冷启动会略微减少一个函数实例可以处理的工作量。</p>
</div>
</div>
<div class="sect2">
<h3 id="_9_5_3_按调度表触发"><a class="anchor" href="#_9_5_3_按调度表触发"></a>9.5.3 按调度表触发</h3>
<div class="paragraph">
<p>函数可以被安排成定期启动或者在特定日期时间启动。调度好的函数按指定的时间间隔启动，轮询源事件流中的新事件，并根据需要进行处理或关闭。轮询期应保持较小的值以保证 SLA，过于频繁的轮询会给FaaS 框架和事件代理带来不适当的负载。</p>
</div>
<div class="paragraph">
<p>基于时间触发器的客户端代码看起来与消费者组滞后触发器示例的客户端代码相同。</p>
</div>
</div>
<div class="sect2">
<h3 id="_9_5_4_使用网络钩子触发"><a class="anchor" href="#_9_5_4_使用网络钩子触发"></a>9.5.4 使用网络钩子触发</h3>
<div class="paragraph">
<p>函数也可以通过直接调用触发，允许与监控框架、调度程序和其他第三方应用程序进行自定义集成。</p>
</div>
</div>
<div class="sect2">
<h3 id="_9_5_5_触发资源事件"><a class="anchor" href="#_9_5_5_触发资源事件"></a>9.5.5 触发资源事件</h3>
<div class="paragraph">
<p>更改资源也可能是一种触发源。例如，创建、更新或删除文件系统里的一个文件可以触发函数，对数据存储中的一行记录进行更新也可以触发函数。由于事件驱动型微服务领域中的大多数事件是通过事件流生成的，因此这种特定的资源触发器在大多数业务工作流中并不常用。但是，当你需要与 FTP 或其他文件服务提供的外部数据集成时，它会非常有用。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_6_用函数执行业务工作"><a class="anchor" href="#_9_6_用函数执行业务工作"></a>9.6 用函数执行业务工作</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FaaS 方法尤其适用于需要灵活地按需进行资源调配的解决方案。简单型拓扑是可采用此方法的一个候选场景，而无状态拓扑、不需要对多个事件流进行确定性处理的拓扑以及伸缩范围非常广的拓扑（比如基于队列的处理）也都是适用的场景。任何对容量需求高度变化的产品都可以从 FaaS 解决方案中获益，因为FaaS 的水平伸缩能力和按需特性可以快速调配和释放计算资源。</p>
</div>
<div class="paragraph">
<p>当不考虑并发性和确定性时，FaaS 解决方案可以非常好地运行。但是，一旦要考虑确定性，就必须非常小心地确保事件流处理的正确性和一致性。与第 10 章将要介绍的基础消费者解决方案非常类似，FaaS解决方案要求你提供事件调度器以确保一致的处理结果。协同分区的数据一次只能由单个函数进行处理，这类似于功能齐全的轻量级框架和重量级框架只能使用单线程的情况。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_7_维持状态"><a class="anchor" href="#_9_7_维持状态"></a>9.7 维持状态</h2>
<div class="sectionbody">
<div class="paragraph">
<p>由于函数的寿命很短，因此大多数基于 FaaS 的有状态的解决方案需要使用外部有状态的服务。部分原因是许多 FaaS 提供商的目标是提供快速、高度可扩展的处理能力单元，而不依赖于数据的位置。如果函数要获得之前操作得到的本地状态，那么当前操作就只能限定在与本地状态相同的节点上执行。这大大降低了 FaaS 供应商的灵活性，因此它们通常强制执行“无本地状态”策略，并要求所有有状态的内容都存储在执行者的外部。</p>
</div>
<div class="paragraph">
<p>如果函数是从“热”状态启动的，那么之前的本地状态可能还是存在的，但无法保证一直都是如此。就像其他所有客户端一样，连接到外部状态存储的函数需要创建到状态存储的连接并使用对应的 API。函数必须对状态进行显式的持久化和检索。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
请确保对函数的状态采取严格的访问限制，杜绝来自其界限上下文外部的任何访问。</p>
</div>
<div class="paragraph">
<p>一些 FaaS 框架已经添加了持久的有状态的函数支持，比如 Microsoft Azure 的 Durable Functions，它抽象了显式的状态管理并允许你使用本地内存，该内存会自动持久化到外部状态存储上。这使得开发者无须针对函数的挂起和唤起来编写代码以显式地存储和检索状态。这大大简化了有状态的工作流的实现，并提供了跨函数实现的标准化状态管理的选项。</p>
</div>
<div class="paragraph">
<p>FaaS 框架会持续成长并包含新的特性。简单的状态管理是基于函数的解决方案中的一个普遍需求，因此请注意你选择的 FaaS 框架中的状态处理的进化情况。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_8_调用其他函数的函数"><a class="anchor" href="#_9_8_调用其他函数的函数"></a>9.8 调用其他函数的函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>函数通常用于执行其他函数，也可以用于编排和编制工作流。函数之间的通信可以通过事件、“请求–响应”调用或二者相结合异步地进行。这些选择在很大程度上取决于 FaaS 框架和界限上下文的问题空间。当实现多函数的解决方案时，通常采用编排和编制的设计模式。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
为了避免乱序处理的问题，请确保完成了一个事件的所有处理之后才处理下一个事件。</p>
</div>
<div class="sect2">
<h3 id="_9_8_1_事件驱动通信模式"><a class="anchor" href="#_9_8_1_事件驱动通信模式"></a>9.8.1 事件驱动通信模式</h3>
<div class="paragraph">
<p>可以将函数的输出作为事件生产到事件流中供其他函数消费。一个界限上下文可能由许多函数和内部事件流组成，每个函数定义了不同的触发和伸缩逻辑。每个函数按照自己的处理速率消费事件、执行工作并生成输出。此类设计的例子如图 9-3 所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image184.png" alt="image184">
</div>
<div class="title">Figure 3. 图 9-3：包含多个函数的事件驱动型 FaaS 拓扑代表一个微服务</div>
</div>
<div class="paragraph">
<p>在本例中，函数 A 独立于函数 B 和函数 C 的触发器而触发。事件流 2 和事件流 3 被认为是内部事件流，界限上下文之外的所有函数都无法访问它们的内容。每个函数都使用相同的消费者组从其源流消费事件，因为这些函数全都处于相同的界限上下文中。这确保了函数可以按与非 FaaS 型微服务一样的方式高效运行。</p>
</div>
<div class="paragraph">
<p>使用基于事件的通信模式有很多优点。拓扑里的每个函数都可以管理自己的消费者偏移量，在工作完成后进行偏移量提交。除了事件流处理之外，函数之间不需要协作。尽管图 9-3 展示的是基于编排的设计模式，但也可以使用编制模式。此外，事件处理过程中的失败不会导致数据丢失，因为事件是在事件代理中持久存储的，下一个函数实例可以方便地进行重新处理。</p>
</div>
</div>
<div class="sect2">
<h3 id="_9_8_2_直接调用模式"><a class="anchor" href="#_9_8_2_直接调用模式"></a>9.8.2 直接调用模式</h3>
<div class="paragraph">
<p>在直接调用模式中，一个函数可以通过其代码直接调用其他函数。对其他函数的直接调用可以是异步的（这是一种“发射即不管”的方式）或是同步的（调用函数并等待返回值）。</p>
</div>
<div class="paragraph">
<p>1. 编排模式与异步的函数调用</p>
</div>
<div class="paragraph">
<p>异步的直接调用引出了基于编排的 FaaS 解决方案。一个函数基于其业务逻辑简单地调用下一个函数，由下一个函数和 FaaS 框架来处理下一步操作，包括任何失败或错误处理。异步的直接调用函数拓扑是一种简单的将函数调用链接到一起的方式。图 9-4 展示了一个例子。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image185.png" alt="image185">
</div>
<div class="title">Figure 4. 图 9-4：一个界限上下文里的编排型异步函数调用</div>
</div>
<div class="paragraph">
<p>函数 A 在处理一批事件时调用函数 B，函数 A 一旦处理完成，就会更新其消费者偏移量并终止运行。同时，函数 B 将继续它的处理并输出数据到输出事件流。</p>
</div>
<div class="paragraph">
<p>异步直接调用的一个主要缺点是难以确保仅在事件得到成功处理时更新消费者偏移量。在这个例子中，因为函数 B 不会返回结果给函数 A，所以函数 B 发生错误时不会阻止工作流提交错误的消费者组偏移量。但是，对一些工作流来说是可以接受事件丢失的，在此类场景中这个问题可以被忽略。</p>
</div>
<div class="paragraph">
<p>另一个潜在的主要问题是，由于多次调用函数 B，事件的处理可能是乱序的。考虑以下函数 A 的代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public int functionA(Event[] events, Context context) {
    for(Event event: events) {
        //执行函数A的处理工作

        //对于每个事件异步调用函数B
        //不等待函数B的返回值
        asyncfunctionB(event);
    }
    context.success();
    return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>在函数 A 的工作逻辑中内联调用函数 B。根据不同的 FaaS 框架，有可能会创建多个函数 B 实例，它们是独立运行的。这将创建一种竞争条件，其中函数 B 的某些实例会早于其他实例完成执行，因此可能会导致乱序的事件处理。</p>
</div>
<div class="paragraph">
<p>类似的，像下面这样编写代码也无法解决顺序问题。因为函数 A 会在函数 B 执行之前批处理所有事件，所以仍然会出现乱序处理的情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public int functionA(Event[] events, Context context) {
    for(Event event: events) {
        //执行函数A的处理工作
    }
    //用批量事件参数异步调用函数B
    asyncFunctionB(events);

    context.success()
    return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>顺序处理要求对于每个事件严格地执行完函数 A 之后再执行函数 B，接着再处理下一个事件。必须完全处理完一个事件之后才能启动下一个事件，否则很可能导致不确定性行为。当函数 A 和函数 B在操作相同的外部数据存储时更是如此，因为函数 B 可能会依赖于函数 A 所写的数据。</p>
</div>
<div class="paragraph">
<p>在许多情况下，异步调用不足以满足界限上下文的需求，因此要考虑是否用编制型的直接调用模式会更合适。</p>
</div>
<div class="paragraph">
<p>2. 编制模式与同步的函数调用</p>
</div>
<div class="paragraph">
<p>同步的函数调用允许调用其他函数并等待结果，然后再处理剩下的业务逻辑。这可以用第 8 章介绍的编制模式来实现。</p>
</div>
<div class="paragraph">
<p>事件流触发的处理。在下面这个例子中，当新事件到达分区的事件流时，会触发编制器函数执行。该函数会启动并开始处理一批输入事件，然后依次向每个函数分发事件。图 9-5 展示了一个在单一的界限上下文中基于函数的编制模式的例子。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image186.png" alt="image186">
</div>
<div class="title">Figure 5. 图 9-5：在一个界限上下文中的编制型同步函数调用</div>
</div>
<div class="paragraph">
<p>以下是编制器的示例代码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public int orchestrationFunction(Event[] events, Context context) {
    for(Event event: events) {
        //同步的函数调用
        Result resultFromA = invokeFunctionA(event);
        Result resultFromB = invokeFunctionB(event, resultFromA);
        Output output = composeOutputEvent(resultFromA, resultFromB); //写到输出事件流
        producer.produce("Output Stream", output);
    }
    //这会通知FaaS框架更新消费者偏移量
    context.success();
    return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>编制器函数按顺序调用函数 A 和函数 B，并等待每个函数的结果。如果需要，可以将函数 A 的输出发送给函数 B。工作流在完全处理完当前事件之后才会开启下一个事件的处理，这确保了按照偏移量顺序来进行事件处理。一旦消费者函数处理完一批事件，它就可以发出一条成功消息并相应地更新偏移量。</p>
</div>
<div class="paragraph">
<p>队列驱动的事件处理。如果使用具有单独提交功能的队列，则每个事件都可以触发一个单独的编制器函数。编制器需要在完成处理工作后向队列提交处理确认。如果编制器未能完成处理工作，那么该任务将被新创建的下一个编制器实例接收。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_9_终止和关闭"><a class="anchor" href="#_9_9_终止和关闭"></a>9.9 终止和关闭</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一旦函数完成其工作，或者存活期限到期（通常配置为 5~10 分钟），就会终止执行。函数实例被挂起并进入休眠状态，在该状态下实例是可以立即恢复的。由于资源或时间限制，挂起的函数最终也可能被彻底清除。</p>
</div>
<div class="paragraph">
<p>你需要确定在函数终止之前如何处理所有建立的连接和分配的资源。如果是作为一个消费者客户端，那么函数实例会被分配特定的事件流分区。终止函数实例而不撤销这些分配可能会导致处理延迟，因为只有在发生超时之后才会重新分配消费者组中的分区处理权。在消费者组执行再平衡或终止的函数实例重新上线并恢复处理之前，来自这些分区的事件不会得到处理。</p>
</div>
<div class="paragraph">
<p>如果一个函数一直在线且正在处理事件，那么关闭连接和再平衡消费者组是没有必要的。该函数可能只会在其存活期限结束时暂时挂起，短暂进入休眠状态，并立即恢复到运行状态。相反，对于仅间歇运行的消费者函数，最好关闭所有连接并放弃事件流分区的分配。下一个函数实例必须重新创建连接，无论其是冷启动还是热启动。当不确定要如何处理时，清除连接通常是一个好的做法：它减轻了外部数据存储和事件代理的负载，并减少了挂起的函数占用分区处理权的机会。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_10_调整函数"><a class="anchor" href="#_9_10_调整函数"></a>9.10 调整函数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>每个函数都有基于其工作量的具体需求。优化函数在执行期间使用的资源可以确保在保持低成本的同时保持高性能。在建立资源和调整函数的参数时，有一些事情需要考虑。</p>
</div>
<div class="sect2">
<h3 id="_9_10_1_分配足够的资源"><a class="anchor" href="#_9_10_1_分配足够的资源"></a>9.10.1 分配足够的资源</h3>
<div class="paragraph">
<p>每个函数可以被分配一定量的 CPU 和内存资源。重要的是要根据函数需求来调整这些参数：过度分配会使成本变高，过少分配则可能导致函数崩溃或耗时太久。</p>
</div>
<div class="paragraph">
<p>最大执行时间是另一个要考虑的因素，因为它限制了函数可能运行的时长。这个参数与批处理的大小密切相关，因为函数处理事件的时间通常与要处理的事件数呈线性关系。将最大执行时间设置为高于处理特定批量大小事件的最大预期时间，以避免不必要的函数超时错误。</p>
</div>
<div class="paragraph">
<p>最后，还必须考虑 FaaS 解决方案的界限上下文中对状态存储的所有外部 I/O。函数的工作负载随输入事件流的变化而变化，有些工作负载需要对外部状态进行持续的 I/O 操作，而其他工作负载只需要零星的I/O。未能提供足够的 I/O 资源会导致吞吐量和性能降低。</p>
</div>
</div>
<div class="sect2">
<h3 id="_9_10_2_批量事件处理的参数"><a class="anchor" href="#_9_10_2_批量事件处理的参数"></a>9.10.2 批量事件处理的参数</h3>
<div class="paragraph">
<p>如果函数无法在其执行时间期限内处理分配给它的批量事件，那么函数的执行就被认为是失败的并且必须重新进行批处理。但是，除非调整分配给函数的执行时间或输入事件的批量大小，否则处理很可能再次失败。因此，必须至少调整以下两项配置中的其中一项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>增加函数的最大执行时间；</p>
</li>
<li>
<p>减小函数要处理的事件的最大批处理大小。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
自己建立到事件代理的连接并管理事件消费的函数，可以做到在执行期间定期提交偏移量，以确保批处理的部分完结。当只是将一批待消费的事件传递给函数进行业务处理时则没办法做到这点，因为它无法在处理过程中更新消费者偏移量。</p>
</div>
<div class="paragraph">
<p>此外，一些事件监听器触发系统（比如亚马逊和微软提供的系统），允许你在出现失败时自动将批处理大小减半，并重新执行失败的函数。随后再发生错误会导致批处理的量再次减半，再次执行函数，直到它能够按时完成处理为止。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_11_faas的伸缩方案"><a class="anchor" href="#_9_11_faas的伸缩方案"></a>9.11 FaaS的伸缩方案</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FaaS 解决方案为工作的并行化提供了卓越的能力，特别是对于数据处理顺序不重要的队列和事件流。对于分区的事件流，如果事件的顺序确实很重要，那么并行化的最大程度会受限于事件流的分区数，就如所有微服务实现那样。</p>
</div>
<div class="paragraph">
<p>伸缩策略通常由 FaaS 框架提供，请检查你的框架文档确认其提供了哪些选项。常见的选项基于消费者滞后度、一天中的特定时间段、处理吞吐量和性能指标等维度进行伸缩。</p>
</div>
<div class="paragraph">
<p>对于自己负责实例化和管理事件代理连接的函数，请注意当消费者进入或离开消费者组时分区分配再平衡的影响。如果消费者频繁地加入或离开消费者组，那么消费者组最终可能会处于一种近乎持续的再平衡状态，从而无法取得处理进展。在极端情况下，其可能会陷入再平衡的虚拟死锁中，函数在其生命周期中反复分配和删除分区。当使用的函数存活期限较短且批处理的量较小时，可能会出现此问题，并且对延迟过于敏感的伸缩策略会使问题变得更糟。建立基于 step 的伸缩策略或使用滞后环可以保障有足够的伸缩响应，同时不会使消费者组进入过度再平衡的状态。</p>
</div>
<div class="paragraph">
<p>静态分区分配消除了动态分配的消费者组的再平衡开销，也可用于协同分区事件流。函数将预先知道它们会从哪些分区进行消费。不需要再平衡，只要触发该函数，就可以简单地消费事件。采用这种方法需要更仔细地考虑函数所执行的工作，因为你需要确保每个分区都能得到消费。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image5.png" alt="image" width="47" height="44"></span>
要小心抖动的触发器和伸缩策略。频繁的分区分配再平衡对事件代理来说是成本高昂的。尽量保证在几分钟的间隔内只能向上或向下进行一次函数的伸缩。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_9_12_小结"><a class="anchor" href="#_9_12_小结"></a>9.12 小结</h2>
<div class="sectionbody">
<div class="paragraph">
<p>FaaS 属于云计算的其中一个领域并且正处在高速发展阶段。许多 FaaS 框架提供了多种函数开发、管理、部署、触发、测试和伸缩工具，让你可以使用函数构建自己的微服务。可以通过事件流中的新事件、消费者组滞后状态、挂钟时间和自定义逻辑触发函数。</p>
</div>
<div class="paragraph">
<p>基于函数的解决方案在处理不需要事件调度的无状态和简单有状态业务问题时特别有用。编制模式可以按严格的顺序调用多个函数，同时也遵从来自事件流的事件顺序。由于 FaaS 框架正在快速地发展，因此保持跟踪你所感兴趣的 FaaS 平台的最新特性是非常重要的。</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="8.html">第 8 章 用微服务构建工作流</a></span>
  <span class="next"><a href="10.html">第 10 章 基础的生产者和消费者微服务</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
