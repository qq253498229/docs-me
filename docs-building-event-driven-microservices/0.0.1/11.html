<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第 11 章 使用重量级框架的微服务 :: docs-me</title>
    <link rel="prev" href="10.html">
    <link rel="next" href="12.html">
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">docs-me</a>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="docs-building-event-driven-microservices" data-version="0.0.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="index.html">微服务与事件驱动架构</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="copyright.html">版权声明</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="o_reilly_media_inc_introduction.html">O&#8217;Reilly Media, Inc. 介绍</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="industry_evaluation.html">业界评论</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="introduction.html">前言</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="typesetting_convention.html">排版约定</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="o_reilly_online_learning_platform.html">O&#8217;Reilly在线学习平台（O&#8217;Reilly Online Learning）</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="contact_us.html">联系我们</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="acknowledgments.html">致谢</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="more_information.html">更多信息</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html">第 1 章 为什么用事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="1.html#_1_1_什么是事件驱动型微服务">1.1 什么是事件驱动型微服务</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_2_领域驱动设计和界限上下文">1.2 领域驱动设计和界限上下文</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_2_1_运用领域模型和界限上下文">1.2.1 运用领域模型和界限上下文</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_2_2_保持界限上下文与业务需求一致">1.2.2 保持界限上下文与业务需求一致</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_3_沟通结构">1.3 沟通结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_1_业务沟通结构">1.3.1 业务沟通结构</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_2_实现沟通结构">1.3.2 实现沟通结构</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_3_数据沟通结构">1.3.3 数据沟通结构</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_3_4_康威定律和沟通结构">1.3.4 康威定律和沟通结构</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_4_传统计算中的沟通结构">1.4 传统计算中的沟通结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_1_选项1创建一个新服务">1.4.1 选项1：创建一个新服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_2_选项2将它加入现有服务中">1.4.2 选项2：将它加入现有服务中</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_3_两种选项的利弊">1.4.3 两种选项的利弊</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_4_团队场景续">1.4.4 团队场景（续）</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_4_5_冲突的压力">1.4.5 冲突的压力</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_5_事件驱动的沟通结构">1.5 事件驱动的沟通结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_1_事件是通信的基础">1.5.1 事件是通信的基础</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_2_事件流提供了单一事实来源">1.5.2 事件流提供了单一事实来源</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_3_消费者执行自己的建模和查询">1.5.3 消费者执行自己的建模和查询</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_4_整个组织的数据沟通得到改善">1.5.4 整个组织的数据沟通得到改善</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_5_5_高可访问的数据利于业务变更">1.5.5 高可访问的数据利于业务变更</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_6_异步的事件驱动型微服务">1.6 异步的事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_使用事件驱动型微服务的示例团队">使用事件驱动型微服务的示例团队</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="1.html#_1_7_同步式微服务">1.7 同步式微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_7_1_同步式微服务的缺点">1.7.1 同步式微服务的缺点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="1.html#_1_7_2_同步式微服务的优点">1.7.2 同步式微服务的优点</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="1.html#_1_8_小结">1.8 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html">第 2 章 事件驱动型微服务基础</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_1_构建拓扑">2.1 构建拓扑</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_1_1_微服务拓扑">2.1.1 微服务拓扑</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_1_2_业务拓扑">2.1.2 业务拓扑</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_2_事件内容">2.2 事件内容</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_3_事件的结构">2.3 事件的结构</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_3_1_无键事件">2.3.1 无键事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_3_2_实体事件">2.3.2 实体事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_3_3_键控事件">2.3.3 键控事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_4_物化来自实体事件的状态">2.4 物化来自实体事件的状态</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_5_事件数据的定义和schema">2.5 事件数据的定义和schema</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_6_微服务单一写原则">2.6 微服务单一写原则</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_7_用事件代理赋能微服务">2.7 用事件代理赋能微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_7_1_事件存储和服务">2.7.1 事件存储和服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_7_2_需要考虑的其他因素">2.7.2 需要考虑的其他因素</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_8_事件代理与消息代理">2.8 事件代理与消息代理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_8_1_从不可变日志中消费">2.8.1 从不可变日志中消费</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_8_2_提供单一事实来源">2.8.2 提供单一事实来源</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="2.html#_2_9_大规模管理微服务">2.9 大规模管理微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_9_1_将微服务放到容器内">2.9.1 将微服务放到容器内</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_9_2_将微服务放到虚拟机内">2.9.2 将微服务放到虚拟机内</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="2.html#_2_9_3_管理容器和虚拟机">2.9.3 管理容器和虚拟机</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_10_缴纳微服务税">2.10 缴纳微服务税</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="2.html#_2_11_小结">2.11 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="3.html">第 3 章 通信和数据契约</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="3.html#_3_1_事件驱动数据契约">3.1 事件驱动数据契约</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_1_使用显式schema作为契约">3.1.1 使用显式schema作为契约</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_2_schema定义的注释">3.1.2 schema定义的注释</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_3_全能的schema演化">3.1.3 全能的schema演化</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_4_有代码生成器支持">3.1.4 有代码生成器支持</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_1_5_破坏性的schema变更">3.1.5 破坏性的schema变更</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="3.html#_3_2_选择事件格式">3.2 选择事件格式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="3.html#_3_3_设计事件">3.3 设计事件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_1_只讲述事实">3.3.1 只讲述事实</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_2_每个流都使用单一事件定义">3.3.2 每个流都使用单一事件定义</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_3_使用最窄的数据类型">3.3.3 使用最窄的数据类型</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_4_保持事件的单一用途">3.3.4 保持事件的单一用途</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_5_最小化事件">3.3.5 最小化事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_6_让潜在的消费者参与事件设计">3.3.6 让潜在的消费者参与事件设计</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="3.html#_3_3_7_避免将事件作为信号量或信号">3.3.7 避免将事件作为信号量或信号</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="3.html#_3_4_小结">3.4 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html">第 4 章 将事件驱动架构与现有系统集成</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_1_什么是数据解放">4.1 什么是数据解放</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_1_1_数据解放的折中方案">4.1.1 数据解放的折中方案</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_1_2_将被解放的数据转化成事件">4.1.2 将被解放的数据转化成事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_2_数据解放模式">4.2 数据解放模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_3_数据解放框架">4.3 数据解放框架</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_4_通过查询实施数据解放">4.4 通过查询实施数据解放</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_1_批量加载">4.4.1 批量加载</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_2_增量时间戳加载">4.4.2 增量时间戳加载</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_3_自增id加载">4.4.3 自增ID加载</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_4_自定义查询">4.4.4 自定义查询</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_5_增量更新">4.4.5 增量更新</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_6_基于查询更新的优点">4.4.6 基于查询更新的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_4_7_基于查询更新的缺点">4.4.7 基于查询更新的缺点</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_5_使用变更数据捕获日志解放数据">4.5 使用变更数据捕获日志解放数据</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_5_1_使用数据存储日志的优点">4.5.1 使用数据存储日志的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_5_2_使用数据库日志的缺点">4.5.2 使用数据库日志的缺点</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_6_使用发件箱表解放数据">4.6 使用发件箱表解放数据</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_1_性能考虑">4.6.1 性能考虑</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_2_隔离内部数据模型">4.6.2 隔离内部数据模型</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_3_确保schema兼容性">4.6.3 确保schema兼容性</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_6_4_使用触发器捕获变更数据">4.6.4 使用触发器捕获变更数据</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="4.html#_4_7_对处于捕获的数据集做数据定义变更">4.7 对处于捕获的数据集做数据定义变更</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_7_1_为查询和cdc日志模式处理事后数据定义变更">4.7.1 为查询和CDC日志模式处理事后数据定义变更</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="4.html#_4_7_2_为变更数据表捕获模式处理数据定义变更">4.7.2 为变更数据表捕获模式处理数据定义变更</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_8_将事件数据落地到数据存储">4.8 将事件数据落地到数据存储</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_9_数据落地和获取对业务的影响">4.9 数据落地和获取对业务的影响</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="4.html#_4_10_小结">4.10 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html">第 5 章 事件驱动处理基础</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_1_构建无状态拓扑">5.1 构建无状态拓扑</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_1_1_转换">5.1.1 转换</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_1_2_分流与合流">5.1.2 分流与合流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_2_对事件流再分区">5.2 对事件流再分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_示例对一个事件流再分区">示例：对一个事件流再分区</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_3_对事件流协同分区">5.3 对事件流协同分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_示例对一个事件流进行协同分区">示例：对一个事件流进行协同分区</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="5.html#_5_4_给消费者实例分配分区">5.4 给消费者实例分配分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_4_1_使用分区分配器分配分区">5.4.1 使用分区分配器分配分区</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_4_2_分配协同分区">5.4.2 分配协同分区</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="5.html#_5_4_3_分区分配策略">5.4.3 分区分配策略</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="5.html#_5_5_从无状态处理实例故障中恢复">5.5 从无状态处理实例故障中恢复</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="5.html#_5_6_小结">5.6 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html">第 6 章 具有确定性的流处理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_1_事件驱动工作流的确定性">6.1 事件驱动工作流的确定性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_2_时间戳">6.2 时间戳</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_2_1_同步分布式时间戳">6.2.1 同步分布式时间戳</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_2_2_处理带时间戳的事件">6.2.2 处理带时间戳的事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_3_事件调度和确定性处理">6.3 事件调度和确定性处理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_1_自定义事件调度器">6.3.1 自定义事件调度器</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_2_基于事件时间处理时间和摄取时间进行处理">6.3.2 基于事件时间、处理时间和摄取时间进行处理</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_3_消费者提取时间戳">6.3.3 消费者提取时间戳</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_3_4_对外部系统的请求响应调用">6.3.4 对外部系统的“请求–响应”调用</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_4_水位">6.4 水位</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_并行处理中的水位">并行处理中的水位</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_5_流时间">6.5 流时间</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_并行处理中的流时间">并行处理中的流时间</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="6.html#_6_6_乱序事件和迟到事件">6.6 乱序事件和迟到事件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_6_1_使用水位和流时间的迟到事件">6.6.1 使用水位和流时间的迟到事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_6_2_乱序事件的原因和影响">6.6.2 乱序事件的原因和影响</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="6.html#_6_6_3_时间敏感的函数和窗口化">6.6.3 时间敏感的函数和窗口化</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_7_处理迟到事件">6.7 处理迟到事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_8_再处理与近实时处理">6.8 再处理与近实时处理</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_9_间歇性故障和迟到事件">6.9 间歇性故障和迟到事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_10_生产者事件代理的连接性问题">6.10 生产者/事件代理的连接性问题</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="6.html#_6_11_小结与延展阅读">6.11 小结与延展阅读</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html">第 7 章 有状态的流</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="7.html#_7_1_状态存储与从事件流中物化状态">7.1 状态存储与从事件流中物化状态</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="7.html#_7_2_记录状态到变更日志事件流">7.2 记录状态到变更日志事件流</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_3_将状态物化至内部状态存储">7.3 将状态物化至内部状态存储</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_1_物化全局状态">7.3.1 物化全局状态</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_2_使用内部状态的优点">7.3.2 使用内部状态的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_3_使用内部状态的缺点">7.3.3 使用内部状态的缺点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_3_4_内部状态的伸缩和恢复">7.3.4 内部状态的伸缩和恢复</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_4_将状态物化至外部状态存储">7.4 将状态物化至外部状态存储</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_4_1_外部状态的优点">7.4.1 外部状态的优点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_4_2_外部状态的缺点">7.4.2 外部状态的缺点</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_4_3_外部状态存储的伸缩和恢复">7.4.3 外部状态存储的伸缩和恢复</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_5_重建与迁移状态存储">7.5 重建与迁移状态存储</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_5_1_重建">7.5.1 重建</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_5_2_迁移">7.5.2 迁移</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="7.html#_7_6_事务与有效一次处理">7.6 事务与有效一次处理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_6_1_示例库存计算服务">7.6.1 示例：库存计算服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_6_2_使用客户端代理事务的有效一次处理">7.6.2 使用“客户端–代理”事务的有效一次处理</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="7.html#_7_6_3_没有客户端代理事务的有效一次处理">7.6.3 没有“客户端–代理”事务的有效一次处理</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="7.html#_7_7_小结">7.7 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html">第 8 章 用微服务构建工作流</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html#_8_1_编排模式">8.1 编排模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_1_1_一个简单的事件驱动编排示例">8.1.1 一个简单的事件驱动编排示例</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_1_2_创建和修改编排的工作流">8.1.2 创建和修改编排的工作流</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_1_3_监控编排的工作流">8.1.3 监控编排的工作流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html#_8_2_编制模式">8.2 编制模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_1_一个简单的事件驱动编制模式例子">8.2.1 一个简单的事件驱动编制模式例子</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_2_一个简单的直接调用的编制模式例子">8.2.2 一个简单的直接调用的编制模式例子</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_3_对比事件驱动编制模式和直接调用的编制模式">8.2.3 对比事件驱动编制模式和直接调用的编制模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_4_创建和修改编制工作流">8.2.4 创建和修改编制工作流</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_2_5_监控编制工作流">8.2.5 监控编制工作流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="8.html#_8_3_分布式事务">8.3 分布式事务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_3_1_编排型事务saga模式">8.3.1 编排型事务：saga模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="8.html#_8_3_2_编制型事务">8.3.2 编制型事务</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="8.html#_8_4_补偿工作流">8.4 补偿工作流</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="8.html#_8_5_小结">8.5 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="9.html">第 9 章 使用“函数即服务”的微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="9.html#_9_1_设计基于函数的微服务解决方案">9.1 设计基于函数的微服务解决方案</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_1_1_确保界限上下文的严格的成员关系">9.1.1 确保界限上下文的严格的成员关系</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_1_2_只在完成处理之后提交偏移量">9.1.2 只在完成处理之后提交偏移量</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_1_3_少即是多">9.1.3 少即是多</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_2_选择faas供应商">9.2 选择FaaS供应商</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_3_在函数之外构建微服务">9.3 在函数之外构建微服务</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_4_冷启动和热启动">9.4 冷启动和热启动</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="9.html#_9_5_用触发器启动函数">9.5 用触发器启动函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_5_1_基于新事件触发事件流监听器">9.5.1 基于新事件触发：事件流监听器</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_5_2_基于消费者组的滞后度触发">9.5.2 基于消费者组的滞后度触发</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_5_3_按调度表触发">9.5.3 按调度表触发</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_5_4_使用网络钩子触发">9.5.4 使用网络钩子触发</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_5_5_触发资源事件">9.5.5 触发资源事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_6_用函数执行业务工作">9.6 用函数执行业务工作</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_7_维持状态">9.7 维持状态</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="9.html#_9_8_调用其他函数的函数">9.8 调用其他函数的函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_8_1_事件驱动通信模式">9.8.1 事件驱动通信模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_8_2_直接调用模式">9.8.2 直接调用模式</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_9_终止和关闭">9.9 终止和关闭</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="9.html#_9_10_调整函数">9.10 调整函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_10_1_分配足够的资源">9.10.1 分配足够的资源</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="9.html#_9_10_2_批量事件处理的参数">9.10.2 批量事件处理的参数</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_11_faas的伸缩方案">9.11 FaaS的伸缩方案</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="9.html#_9_12_小结">9.12 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="10.html">第 10 章 基础的生产者和消费者微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="10.html#_10_1_bpc的适用场合">10.1 BPC的适用场合</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_1_集成现有遗留系统">10.1.1 集成现有遗留系统</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_2_不依赖于事件顺序的有状态的业务逻辑">10.1.2 不依赖于事件顺序的有状态的业务逻辑</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_3_当数据层完成大部分工作时">10.1.3 当数据层完成大部分工作时</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_10_1_4_处理层和数据层独立伸缩">10.1.4 处理层和数据层独立伸缩</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="10.html#_10_2_具有外部流处理的混合bpc应用程序">10.2 具有外部流处理的混合BPC应用程序</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="10.html#_示例使用外部流处理框架来联结事件流">示例：使用外部流处理框架来联结事件流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="10.html#_10_3_小结">10.3 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="11.html">第 11 章 使用重量级框架的微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_11_1_重量级框架的简单历史">11.1 重量级框架的简单历史</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_11_2_重量级框架的内部运作">11.2 重量级框架的内部运作</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_11_3_优点和局限性">11.3 优点和局限性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#_11_4_集群搭建方案和执行模式">11.4 集群搭建方案和执行模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_11_4_1_使用托管服务">11.4.1 使用托管服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_11_4_2_构建自己的完整集群">11.4.2 构建自己的完整集群</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_11_4_3_使用cms集成来创建集群">11.4.3 使用CMS集成来创建集群</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#_11_5_应用程序提交模式">11.5 应用程序提交模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_11_5_1_驱动器模式">11.5.1 驱动器模式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_11_5_2_集群模式">11.5.2 集群</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_11_6_处理状态和使用检查点">11.6 处理状态和使用检查点</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#_11_7_伸缩应用程序和处理事件流分区">11.7 伸缩应用程序和处理事件流分区</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_11_7_1_伸缩运行中的应用程序">11.7.1 伸缩运行中的应用程序</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_11_7_2_通过重启伸缩应用程序">11.7.2 通过重启伸缩应用程序</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="#_11_7_3_自动伸缩应用程序">11.7.3 自动伸缩应用程序</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_11_8_从故障中恢复">11.8 从故障中恢复</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_11_9_考虑多租户问题">11.9 考虑多租户问题</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_11_10_语言和语法">11.10 语言和语法</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_11_11_选择一个框架">11.11 选择一个框架</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_11_12_示例点击和观看的会话窗口">11.12 示例：点击和观看的会话窗口</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#_11_13_小结">11.13 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="12.html">第 12 章 使用轻量级框架的微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_1_优点和局限性">12.1 优点和局限性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_2_轻量级处理">12.2 轻量级处理</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_3_处理状态和使用变更日志">12.3 处理状态和使用变更日志</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="12.html#_12_4_伸缩和故障恢复">12.4 伸缩和故障恢复</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_4_1_事件洗牌">12.4.1 事件洗牌</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_4_2_状态分配">12.4.2 状态分配</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_4_3_状态复制和热副本">12.4.3 状态复制和热副本</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="12.html#_12_5_选择一个轻量级框架">12.5 选择一个轻量级框架</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_5_1_apache_kafka_streams">12.5.1 Apache Kafka Streams</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="12.html#_12_5_2_apache_samza嵌入模式">12.5.2 Apache Samza：嵌入模式</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_6_语言和语法">12.6 语言和语法</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_7_流表表联结增强模式">12.7 流–表–表联结：增强模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="12.html#_12_8_小结">12.8 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html">第 13 章 集成事件驱动型和“请求–响应”型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_1_处理外部事件">13.1 处理外部事件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_1_1_自动生成的事件">13.1.1 自动生成的事件</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_1_2_由响应生成的事件">13.1.2 由响应生成的事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_2_处理自动生成的分析事件">13.2 处理自动生成的分析事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_3_集成第三方请求响应api">13.3 集成第三方“请求–响应”API</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_4_处理并提供有状态的数据">13.4 处理并提供有状态的数据</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_4_1_实时请求内部状态存储">13.4.1 实时请求内部状态存储</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_4_2_实时请求外部状态存储">13.4.2 实时请求外部状态存储</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_5_在事件驱动的工作流中处理请求">13.5 在事件驱动的工作流中处理请求</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_处理用户界面事件">处理用户界面事件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_6_请求响应应用程序中的微前端">13.6 “请求–响应”应用程序中的微前端</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_7_微前端的优点">13.7 微前端的优点</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_7_1_基于组合的微服务">13.7.1 基于组合的微服务</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_7_2_容易与业务需求对齐">13.7.2 容易与业务需求对齐</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="13.html#_13_8_微前端的缺点">13.8 微前端的缺点</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_8_1_可能不一致的ui元素和样式">13.8.1 可能不一致的UI元素和样式</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_8_2_不同的微前端性能">13.8.2 不同的微前端性能</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="13.html#_13_8_3_示例体验搜索与评论应用程序">13.8.3 示例：体验搜索与评论应用</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="13.html#_13_9_小结">13.9 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="14.html">第 14 章 支持性工具</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_1_微服务团队分配系统">14.1 微服务–团队分配系统</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_2_事件流的创建和修改">14.2 事件流的创建和修改</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_3_事件流元数据标记">14.3 事件流元数据标记</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_4_限额">14.4 限额</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_5_schema注册表">14.5 schema注册表</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_6_schema创建和修改通知">14.6 schema创建和修改通知</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_7_偏移量管理">14.7 偏移量管理</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_8_事件流的权限和访问控制列表">14.8 事件流的权限和访问控制列表</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_9_状态管理和应用程序重置">14.9 状态管理和应用程序重置</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_10_消费者偏移量滞后度监控">14.10 消费者偏移量滞后度</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_11_流水线型的微服务创建流程">14.11 流水线型的微服务创建流程</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_12_容器管理控制">14.12 容器管理控制</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="14.html#_14_13_集群创建和管理">14.13 集群创建和管理</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_1_事件代理的程序化创建">14.13.1 事件代理的程序化创建</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_2_计算资源的程序化创建">14.13.2 计算资源的程序化创建</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_3_跨集群事件数据复制">14.13.3 跨集群事件数据复制</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_14_13_4_工具的程序化创建">14.13.4 工具的程序化创建</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="14.html#_14_14_依赖跟踪和拓扑可视化">14.14 依赖跟踪和拓扑可视化</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="14.html#_拓扑示例">拓扑示例</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="14.html#_14_15_小结">14.15 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="15.html">第 15 章 测试事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_1_通用测试原则">15.1 通用测试原则</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="15.html#_15_2_单元测试拓扑函数">15.2 单元测试拓扑函数</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_2_1_无状态的函数">15.2.1 无状态的函数</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_2_2_有状态的函数">15.2.2 有状态的函数</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_3_测试拓扑">15.3 测试拓扑</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_4_测试schema演化和兼容性">15.4 测试schema演化和兼容性</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_5_事件驱动型微服务的集成测试">15.5 事件驱动型微服务的集成测试</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="15.html#_15_6_本地集成测试">15.6 本地集成测试</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_6_1_在测试代码的运行时内创建临时环境">15.6.1 在测试代码的运行时内创建临时环境</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_6_2_在测试代码外部创建临时环境">15.6.2 在测试代码外部创建临时环境</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_6_3_使用mocking和模拟器方法集成托管服务">15.6.3 使用mocking和模拟器方法集成托管</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_6_4_集成没有本地支持的远程服务">15.6.4 集成没有本地支持的远程服务</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="15.html#_15_7_完全远程集成测试">15.7 完全远程集成测试</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_7_1_程序化创建临时集成测试环境">15.7.1 程序化创建临时集成测试环境</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_7_2_使用共享环境进行测试">15.7.2 使用共享环境进行测试</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="15.html#_15_7_3_使用生产环境进行测试">15.7.3 使用生产环境进行测试</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_8_选择你的完全远程集成测试策略">15.8 选择你的完全远程集成测试策略</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="15.html#_15_9_小结">15.9 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="16.html">第 16 章 部署事件驱动型微服务</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_1_微服务部署的原则">16.1 微服务部署的原则</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="16.html#_16_2_微服务部署的架构组件">16.2 微服务部署的架构组件</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_2_1_持续集成系统持续交付系统和持续部署系统">16.2.1 持续集成系统、持续交付系统和持续部署</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_2_2_cms和商业硬件">16.2.2 CMS和商业硬件</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_3_基本的全站式部署模式">16.3 基本的全站式部署模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_4_滚动更新模式">16.4 滚动更新模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="16.html#_16_5_破坏性的schema变更模式">16.5 破坏性的schema变更模式</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_5_1_通过两个事件流达到最终迁移">16.5.1 通过两个事件流达到最终迁移</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="16.html#_16_5_2_同步迁移到新事件流">16.5.2 同步迁移到新事件流</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_6_蓝绿部署模式">16.6 蓝绿部署模式</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="16.html#_16_7_小结">16.7 小结</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="17.html">第 17 章 结论</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_1_通信层">17.1 通信层</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_2_业务领域和界限上下文">17.2 业务领域和界限上下文</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_3_可共享的工具和基础设施">17.3 可共享的工具和基础设施</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_4_结构化事件">17.4 结构化事件</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_5_数据解放和单一事实来源">17.5 数据解放和单一事实来源</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_6_微服务">17.6 微服务</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_7_微服务实现方案">17.7 微服务实现方案</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_8_测试">17.8 测试</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_9_部署">17.9 部署</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="17.html#_17_10_结语">17.10 结语</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="about_author.html">关于作者</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="about_cover.html">关于封面</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">微服务与事件驱动架构</span>
    <span class="version">0.0.1</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../docs-config/0.0.1/index.html">docs-config</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-config/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-steam-electron/0.0.1/index.html">docs-steam-electron</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-steam-electron/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-xiuxian/0.0.1/index.html">docs-xiuxian</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-xiuxian/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-es-java/7.16.0/introduction.html">ES Java API Client</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-es-java/7.16.0/introduction.html">7.16.0</a>
        </li>
        <li class="version">
          <a href="../../docs-es-java/6.8.0/preface.html">6.8.0</a>
        </li>
        <li class="version">
          <a href="../../docs-es-java/6.2.2/1Preface/readme.html">6.2.2</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-greenworks-js/0.0.1/index.html">Greenworks-JS 文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-greenworks-js/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-rust-libp2p/0.0.1/index.html">libp2p入门</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-rust-libp2p/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-neutralino-api/0.0.1/index.html">NeutralinoJS 文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-neutralino-api/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-antora-oauth2.1/0.0.1/index.html">OAuth 2.1 授权框架</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-antora-oauth2.1/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-pd2/0.0.1/index.html">PD2记录</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-pd2/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-peerjs/0.0.1/index.html">PEER JS</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-peerjs/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-actuator/3.3.3/index.html">Spring Boot Actuator</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-actuator/3.3.3/index.html">3.3.3</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-oauth2/0.0.1/index.html">Spring Boot OAuth2</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-oauth2/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-steamworks-rs/0.11.0/index.html">Steamworks for Rust</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-steamworks-rs/0.11.0/index.html">0.11.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-tauri/v1/index.html">Tauri API 文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-tauri/v1/index.html">v1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-testing-angular/中文/start.html">Testing Angular</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-testing-angular/中文/start.html">中文</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-me/0.0.1/index.html">个人记录</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-me/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-taiwu/0.0.1/index.html">太吾绘卷</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-taiwu/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-palworld/0.0.1/index.html">幻兽帕鲁笔记</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-palworld/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="index.html">微服务与事件驱动架构</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-hunter/0.0.1/index.html">猎人-荒野的呼唤</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-hunter/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-logitech/v8.45/index.html">罗技鼠标宏文档</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-logitech/v8.45/index.html">v8.45</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../docs-milk/0.0.1/index.html">银河奶牛</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../docs-milk/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../docs-me/0.0.1/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">微服务与事件驱动架构</a></li>
    <li><a href="11.html">第 11 章 使用重量级框架的微服务</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="https://github.com/qq253498229/docs-building-event-driven-microservices/edit/master/modules/ROOT/pages/11.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="目录" data-levels="3">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">第 11 章 使用重量级框架的微服务</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本章和第 12 章将介绍事件驱动处理中最常用的全功能框架。这些框架通常被称为流框架，它们提供了处理数据流的机制和 API，并且经常用于向事件代理消费和生成事件。这些框架大致可以分为本章介绍的重量级框架和第 12 章介绍的轻量级框架。这两章的目的不是比较这些技术，而是对这些框架如何工作进行概述。然而，有些内容会研究特定框架的特性，特别是当它们涉及以类似微服务的方式实现应用程序时。为了介绍重量级框架，本章会用 Apache Spark、Apache Flink、Apache Storm、Apache Heron 和Apache Bean 模型的概念作为例子。</p>
</div>
<div class="paragraph">
<p>重量级流框架的其中一个定义属性是它需要独立的处理资源集群来执行操作。这个集群通常由许多可共享的工作者节点以及一些负责安排和协调工作的主节点组成。此外，领先的 Apache 解决方案传统上依赖于Apache ZooKeeper（另一个集群服务）来提供高可用性支持和协调集群领导者的选举。尽管 ZooKeeper对于将重量级集群引入生产环境并不是绝对必要的，但是在创建自己的集群时，你应该仔细评估是否需要它。</p>
</div>
<div class="paragraph">
<p>重量级框架的第二个定义属性是它有自己的失败处理、恢复、资源分配、任务分配、数据存储、通信以及处理实例和任务之间进行协调的内部机制。与轻量级框架、FaaS 和 BPC 实现不同，这些方案重度依赖于CMS 和事件代理来实现上述功能。</p>
</div>
<div class="paragraph">
<p>这两个属性就是这些框架为什么被称为“重量级”的主要原因。必须独立于事件代理和 CMS 来管理和维护额外的集群框架，这不是一个小任务。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
一些重量级框架正在向类似轻量级的执行模型演进。这些轻量级模型能与用于操作其他微服务实现的 CMS 很好地集成。</p>
</div>
<div class="paragraph">
<p>你可能已经注意到，重量级框架做了很多 CMS 和事件代理已经处理的事情。CMS 可以管理资源分配、失败、恢复和系统伸缩，而事件代理可以提供微服务实例之间基于事件的通信。重量级框架是融合了 CMS和事件代理能力的独立解决方案。第 12 章将展开更多关于轻量级框架的话题。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_1_重量级框架的简单历史"><a class="anchor" href="#_11_1_重量级框架的简单历史"></a>11.1 重量级框架的简单历史</h2>
<div class="sectionbody">
<div class="paragraph">
<p>重量级流处理框架直接继承自它们的重量级批处理前辈，其中最广为人知的是发布于 2006 年的 Apache Hadoop，它提供了所有人都可以使用的开源大数据技术。Hadoop 将许多技术绑定在一起以提供海量并行处理、失败恢复、数据持久性和内部节点通信等功能，它使得用户可以廉价地使用硬件并轻松地解决需要数千个（或更多）节点才能解决的问题。</p>
</div>
<div class="paragraph">
<p>MapReduce 是最早广泛使用的处理超大批量数据（又称大数据）的方法之一，不过，虽然功能强大，但与当今的许多方案相比，它的执行速度很慢。随着时间的推移，大数据的规模在稳步增长。尽管早期数百（或数千）GB 的工作负载很常见，但今天的工作负载已经扩展到了 TB 和 PB 的规模。随着这些数据集的增长，对更快的处理、更强大的方案、更简单的执行方案以及能够提供近实时流处理能力的解决方案的需求也随之增长。</p>
</div>
<div class="paragraph">
<p>这就是 Spark、Flink、Storm、Heron 和 Beam 发挥作用的地方。开发这些解决方案是为了处理数据流，并比基于批处理的 MapReduce 作业更快地提供可操作的结果。一些解决方案，如 Storm 和 Heron，是单纯处理数据流的技术，它们当前还没有提供批处理能力。其他一些解决方案，如 Spark 和 Flink，则将批处理和流处理融合到了一个解决方案中。</p>
</div>
<div class="paragraph">
<p>这些技术无疑是大多数大数据爱好者所熟悉的，而且可能已经在许多组织的数据科学和分析部门得到了一定程度的应用。事实上，当这些团队将现有的基于批处理的作业转换为基于流的管道时，就是许多组织开始涉足事件驱动处理的原因。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_2_重量级框架的内部运作"><a class="anchor" href="#_11_2_重量级框架的内部运作"></a>11.2 重量级框架的内部运作</h2>
<div class="sectionbody">
<div class="paragraph">
<p>前面提到的重量级开源 Apache 框架都是以非常类似的方式运行的。像谷歌的 Dataflow 这样的专有解决方案，是使用 Apache Beam 的 API 编写的应用程序来执行的，可能是以类似的方式运行，但这只是一个假设，因为它并没有开放源代码，也没有对后端机制的详细描述。详细描述重量级框架的一个挑战是，每个框架都有自己的操作和设计细节，而对每个框架的全面介绍远远超出了本章所能涵盖的范围。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
对于你所选择的重量级框架，一定要仔细阅读介绍其运行机制的文档。</p>
</div>
<div class="paragraph">
<p>重量级流处理集群是一组专用的处理和存储资源，分为两个主要角色。第一个角色是主节点，它对工作者节点上的执行者和任务进行优先级排序、分配和管理。第二个角色是执行者，它使用工作者节点可用的处理能力、内存、本地和远程磁盘来完成这些任务。在事件驱动处理中，这些任务会连接到事件代理并从事件流中消费事件。图 11-1 展示了这个工作的粗略分解。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image195.png" alt="image195">
</div>
<div class="title">Figure 1. 图 11-1：重量级流处理框架通用视图</div>
</div>
<div class="paragraph">
<p>图 11-1 也展示了 Apache ZooKeeper，它扮演着这个流集群的支持角色。Zookeeper 提供了高可靠的分布式协调能力，并用于确定负责的主节点（因为节点发生故障的情况并不少见，无论是工作者节点、主节点还是 ZooKeeper 节点）。当主节点发生故障时，ZooKeeper 会帮助确定剩余的主节点中哪一个是新的领导者，以确保操作的连续性。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image4.png" alt="image" width="40" height="46"></span>
ZooKeeper 在历史上一直是提供分布式重量级框架协调能力的主要组件。新的框架可能使用也可能不使用 ZooKeeper。无论哪种情况，分布式协调对于可靠运行分布式负载都是至关重要的。</p>
</div>
<div class="paragraph">
<p>作业是用框架的软件开发包（SDK）构建的流处理拓扑，其作用是解决具体界限上下文的问题。它在集群中持续运行，在事件到达时处理事件，就像本书中描述的任何其他微服务一样。</p>
</div>
<div class="paragraph">
<p>作业被提交到集群之后，其所定义的流处理拓扑被分解为任务并分配给工作者节点。任务管理器会监控任务并确保它们得到完成。当发生故障时，任务管理器会挑选一个可用的执行者重新开启工作。任务管理器通常是按高可用标准搭建的，这样如果任务管理器运行的节点发生故障，则可以由备份节点替代，以防止所有正在运行的作业发生失败。</p>
</div>
<div class="paragraph">
<p>图 11-2 展示了一个通过主节点 1 提交到集群的作业，而该作业又被转换成了任务供执行者处理。这些长期运行的任务建立了到事件代理的连接，并开始从事件流消费事件。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image196.png" alt="image196">
</div>
<div class="title">Figure 2. 图 11-2：提交流处理作业以从事件流中读取数据</div>
</div>
<div class="paragraph">
<p>虽然这个例子展示了任务和流分区 1∶1 映射的情况，但是我们也可以配置希望应用程序使用的并行数量。既可以让一个任务消费所有分区，也可以让多个任务消费同一个分区，比如使用队列的情况。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_3_优点和局限性"><a class="anchor" href="#_11_3_优点和局限性"></a>11.3 优点和局限性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章讨论的重量级框架主要用于分析技术。它们对于用近乎实时的方式分析大量事件以快速做出决定有重大的价值。以下是一些相当常见的使用模式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>抽取数据、转换并将其加载到新的数据存储（ETL）中；</p>
</li>
<li>
<p>执行基于会话和窗口的分析；</p>
</li>
<li>
<p>发现异常行为模式；</p>
</li>
<li>
<p>聚合流并维持状态；</p>
</li>
<li>
<p>执行任何类型的无状态流操作。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些框架功能强大且相当成熟，许多组织在使用它们，并对其源代码做出了贡献。有大量的图书和博客文章、出色的文档以及许多示例应用程序可供你查阅。</p>
</div>
<div class="paragraph">
<p>然而，这些框架有几个相当重要的缺点会对基于它们的微服务应用程序产生限制（但并不是说完全不可用）。</p>
</div>
<div class="paragraph">
<p>首先，这些重量级框架最初的设计并没有考虑微服务类型的部署。部署这些应用程序需要一个专用的资源集群，而不仅仅是事件代理和 CMS，这增加了管理大规模应用程序的复杂性。随着新的部署技术的开发，有一些方法可以减轻这种复杂性，其中一些将在本章后面详细介绍。</p>
</div>
<div class="paragraph">
<p>其次，这些框架大部分是基于 Java 虚拟机（Java virtual machine，JVM）的，这限制了用来创建单独的微服务应用程序的实现语言。常见的解决方法是使用重量级框架作为独立的应用程序来执行转换操作，而采用另一种语言的独立应用程序通过转换后的状态存储提供业务功能。</p>
</div>
<div class="paragraph">
<p>再次，并非所有框架都支持将实体流物化为永久保留的表。这就排除了创建表联结和流–表联结以及图10-3 所示的浇注模式之类的实现模式。</p>
</div>
<div class="paragraph">
<p>即使重量级框架确实支持流的物化和联结，在文档中也常常不会很明显地体现这一特性。这些框架中有很多框架会将重点聚焦于基于时间的聚合，例如，相关的博客文章和广告都在强调时间序列分析和基于有限窗口大小的聚合。仔细挖掘后会发现，主流框架提供了一个全局窗口，该窗口允许事件流的物化。从这里开始，你可以实现自己的自定义联结特性，尽管如此，考虑到它们在组织中处理大规模事件流的重要性，这些特性的文档化和展示程度仍然远远不如它们应有的好。</p>
</div>
<div class="paragraph">
<p>以上缺点再一次表明了这些框架在设计和实现时，主要考虑的是应对分析类型的工作负载。对每个实现的技术改进和对独立于实现的公共 API（如 Apache Beam）的优化投入正在推动重量级框架领域的不断变化，而这些框架的新版本能带来什么很值得我们关注。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_4_集群搭建方案和执行模式"><a class="anchor" href="#_11_4_集群搭建方案和执行模式"></a>11.4 集群搭建方案和执行模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>搭建和管理重量级流处理集群有许多可选的方案，每一个选项都有其优点和缺点。</p>
</div>
<div class="sect2">
<h3 id="_11_4_1_使用托管服务"><a class="anchor" href="#_11_4_1_使用托管服务"></a>11.4.1 使用托管服务</h3>
<div class="paragraph">
<p>首先，管理集群最简单的方式就是付钱让别人来做。正如有许多计算服务供应商一样，也有一些供应商愿意为你托管集群并管理你的大部分操作需求。与启动自己的集群的预算成本相比，这通常是最昂贵的方案，但它大大减少了操作开销，并消除了对内部专业知识的要求。例如，亚马逊提供了托管 Flink 和Spark 服务；谷歌、Databricks 和微软提供了它们自己的 Spark 捆绑服务；谷歌提供了 Dataflow（它自己实现的 Apache Beam 的运行器）。</p>
</div>
<div class="paragraph">
<p>需要注意的一点是，这些服务似乎在不断向完全无服务器的方式发展，在这种方式中，整个物理集群对作为订阅者的你是不可见的。根据你的安全性、性能和数据隔离要求的不同，这种方式可能是可接受的，也可能是不可接受的。请确保了解这些服务供应商能提供什么和不能提供什么，因为它们可能不包括独立运行的集群的所有功能。</p>
</div>
</div>
<div class="sect2">
<h3 id="_11_4_2_构建自己的完整集群"><a class="anchor" href="#_11_4_2_构建自己的完整集群"></a>11.4.2 构建自己的完整集群</h3>
<div class="paragraph">
<p>一个重量级的框架可能有自己独立于 CMS 的专用可伸缩资源集群。这种部署是重量级集群的历史常态，因为它密切模拟了原始的 Hadoop。当重量级框架被需要大量（成百上千个）工作者节点的服务使用时，这是很常见的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_11_4_3_使用cms集成来创建集群"><a class="anchor" href="#_11_4_3_使用cms集成来创建集群"></a>11.4.3 使用CMS集成来创建集群</h3>
<div class="paragraph">
<p>集群也可以连同 CMS 一起被创建。第一种模式只涉及在 CMS 提供的资源上部署集群，而第二种模式涉及利用 CMS 本身作为伸缩和部署单个作业的手段。用 CMS 部署集群的主要优点是可以获得 CMS 提供的监控、日志和资源管理功能。伸缩集群也变成了简单地添加或移除所需节点类型的操作。</p>
</div>
<div class="paragraph">
<p>1. 使用 CMS 部署和运行集群</p>
</div>
<div class="paragraph">
<p>使用 CMS 部署重量级集群有许多优点。主节点、工作者节点和 ZooKeeper（如果适用的话）在它们自己的容器或虚拟机中启动。这些容器像其他容器一样受到管理和监控，CMS 提供了故障可视化以及自动重启这些实例的方法。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
你可以强制静态分配主节点和其他任何需要高可用性的服务，以防止 CMS 在伸缩底层计算资源时将它们搞乱。这可以防止来自集群监控器的关于主节点丢失的过度警报。</p>
</div>
<div class="paragraph">
<p>2. 使用 CMS 为单个作业指定资源</p>
</div>
<div class="paragraph">
<p>历史上，重量级集群要负责为每个提交的应用程序分配和管理资源。近年来 CMS 的引入可以为你做同样的事情，同时它也可以管理所有其他的微服务实现。当重量级集群需要更多的资源来扩容时，它必须首先从 CMS 请求并获取资源。可以将这些资源添加到集群的资源池中，最后根据需要分配给应用程序。</p>
</div>
<div class="paragraph">
<p>Spark 和 Flink 使你能够直接利用 Kubernetes 进行可伸缩的应用程序部署，而不仅仅是其原来的专用集群配置，其中每个应用程序都有自己的专用工作者节点集。例如，Apache Flink 允许应用程序使用 Kubernetes 在它们自己的独立会话集群中独立运行。Apache Spark 提供了类似的选项，允许 Kubernetes 扮演主节点的角色，并为每个应用程序维护隔离的工作资源。图 11-3 是这一工作原理的基本概述。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image220.png" alt="image220">
</div>
<div class="title">Figure 3. 图 11-3：Kubernetes 集群部署和管理的一个作业</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
此部署模式与部署非重量级微服务的方式几乎相同，并将轻量级和 BPC 部署策略融合在了一起。</p>
</div>
<div class="paragraph">
<p>这种部署模式有以下优点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>利用了 CMS 的资源获取模型，包括伸缩需求；</p>
</li>
<li>
<p>作业之间是完全隔离的；</p>
</li>
<li>
<p>可以使用不同的框架和版本；</p>
</li>
<li>
<p>重量级流应用程序可以像微服务一样处理，并且使用相同的部署流程。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当然，这种模式也有一些缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不是所有的主流重量级流框架都支持此模式；</p>
</li>
<li>
<p>不是所有主流的 CMS 都支持这种集成；</p>
</li>
<li>
<p>可能还无法支持如自动伸缩这种在完全的集群模式中可用的特性。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_5_应用程序提交模式"><a class="anchor" href="#_11_5_应用程序提交模式"></a>11.5 应用程序提交模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>将应用程序提交到重量级集群进行处理有两种主要方式：驱动器模式和集群模式。</p>
</div>
<div class="sect2">
<h3 id="_11_5_1_驱动器模式"><a class="anchor" href="#_11_5_1_驱动器模式"></a>11.5.1 驱动器模式</h3>
<div class="paragraph">
<p>Spark 和 Flink 支持驱动器模式。尽管驱动器在集群资源内运行，但它仅仅是一个帮助协调和执行用户应用程序的独立的本地程序。驱动器协调集群以确保应用程序的进度，并可用于报告错误、执行日志记录和完成其他操作。值得注意的是，驱动器的终止会导致应用程序的终止，这提供了一种部署和终止重量级流应用程序的简单机制。可以使用 CMS 把应用程序驱动器当作微服务进行部署，并从重量级集群中获取工作者资源。终止驱动器的操作和停止任何其他微服务一样。</p>
</div>
</div>
<div class="sect2">
<h3 id="_11_5_2_集群模式"><a class="anchor" href="#_11_5_2_集群模式"></a>11.5.2 集群模式</h3>
<div class="paragraph">
<p>Spark 和 Flink 支持集群模式，并且这也是 Storm 和 Heron 作业的默认部署模式。在集群模式下，整个应用程序被提交到集群进行管理和执行，然后将一个唯一的 ID 返回给调用函数。这个唯一的 ID 对于识别应用程序和通过集群的 API 向其发出命令是必需的。在这种部署模式下，命令必须直接与集群通信进而部署和停止应用程序，这可能不适合你的微服务部署管道。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_6_处理状态和使用检查点"><a class="anchor" href="#_11_6_处理状态和使用检查点"></a>11.6 处理状态和使用检查点</h2>
<div class="sectionbody">
<div class="paragraph">
<p>可以使用内部状态存储或外部状态存储（参见第 7 章）来持久化有状态的操作，尽管为了高性能和高可伸缩性，大部分重量级框架倾向于内部状态存储。有状态的记录保存在内存中以供快速访问，但是当状态增长到超出可用内存时，出于数据持久化目的，状态也会溢出到磁盘上。使用内部状态存储确实会带来一些风险，比如磁盘故障导致的状态丢失、节点故障以及 CMS 主动伸缩导致的临时状态中断。然而，能获得的性能提升往往远远超过潜在的风险，而风险可以通过仔细的规划来缓解。</p>
</div>
<div class="paragraph">
<p>检查点是应用程序当前内部状态的快照，可在伸缩或节点故障发生之后用于重建状态。为了防止数据丢失，可以将检查点持久化到应用程序工作者节点外部的持久性存储器上。保存检查点可以使用所有与框架兼容的存储方案，比如 Hadoop 分布式文件系统（HDFS，一种通用选项）或者高可用的外部数据存储。然后，每个分区状态存储可以从检查点进行恢复，这在应用程序发生故障的情况下提供了完全恢复功能，在伸缩和工作者节点发生故障的情况下提供了部分恢复功能。</p>
</div>
<div class="paragraph">
<p>当消费和处理分区的事件流时，检查点机制必须考虑两个主要状态。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">算子状态</dt>
<dd>
<p>指 &lt;partitionId,offset&gt; 这对值。检查点必须确保内部键的状态（参见下一条）能匹配上每个分区的消费者偏移量。每个 partitionId 在所有输入主题中是唯一的。</p>
</dd>
<dt class="hdlist1">键控状态</dt>
<dd>
<p>指 &lt;key,state&gt; 这对值。这是与键控实体相关的状态，比如在聚合、缩减、窗口化、联结和其他有状态操作期间的状态。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>算子状态和键控状态必须同步记录，以便键控状态能够准确地表示算子状态已消费的所有事件的处理。如果无法同步记录，则可能导致事件无法被全部处理或者会被重复处理。记录到检查点的状态例子如图 11-4 所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image322.png" alt="image322">
</div>
<div class="title">Figure 4. 图 11-4：有算子状态和键控状态的检查点</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
恢复检查点状态在功能上等同于使用快照恢复外部状态存储，如 7.4.3 节所述。</p>
</div>
<div class="paragraph">
<p>在从检查点完全加载与应用程序任务相关的状态之后，你才能处理新的数据。重量级框架还必须验证每个任务的算子状态与相关的键控状态是否匹配，以确保在任务之间正确分配分区。本章开头介绍的每个主流的重量级框架都有自己的检查点实现方式，因此一定要查看相应的文档以了解详细信息。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_7_伸缩应用程序和处理事件流分区"><a class="anchor" href="#_11_7_伸缩应用程序和处理事件流分区"></a>11.7 伸缩应用程序和处理事件流分区</h2>
<div class="sectionbody">
<div class="paragraph">
<p>重量级应用程序的最大并行度受第 5 章中讨论的因素的限制。一个典型的有状态流处理器会受限于最小分区流的分区数。因为重量级的处理框架特别适合计算大量用户生成的数据，所以在白天看到具有大量计算需求夜晚却很少的循环模式是很常见的。一个每日循环模式的例子如图 11-5 所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image323.png" alt="image323">
</div>
<div class="title">Figure 5. 图 11-5：数据量每日循环的例子</div>
</div>
<div class="paragraph">
<p>处理此类数据的应用程序会极大地受益于能随着需求的增加而扩容以及随着需求的减少而缩容的能力。适当的伸缩可以确保应用程序有足够的容量及时处理所有事件，不会因过度配置而浪费资源。理想情况下，接收事件到完全处理完事件之间的延迟应该尽可能小，尽管许多应用程序对暂时升高的延迟并不敏感。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image5.png" alt="image" width="47" height="44"></span>
伸缩应用程序与伸缩集群是不同的。这里讨论的所有伸缩都是在集群有足够资源的前提下来提升应用程序的并行度。有关集群资源的伸缩，请参阅框架文档。</p>
</div>
<div class="paragraph">
<p>无状态流的应用程序非常易于扩缩容。应用程序的新处理资源可以被轻易地加入消费者组或从中移除，加入或移除时，消费者组会进行资源再平衡并恢复流处理。处理有状态的应用程序则要困难得多：不仅要加载状态到分配给应用程序的工作者节点上，还要让加载的状态匹配输入事件流分区的分配。</p>
</div>
<div class="paragraph">
<p>伸缩有状态的应用程序有两种主要策略，虽然具体的策略因技术而异，但它们有一个共同的目标，即最小化应用程序的中断时间。</p>
</div>
<div class="sect2">
<h3 id="_11_7_1_伸缩运行中的应用程序"><a class="anchor" href="#_11_7_1_伸缩运行中的应用程序"></a>11.7.1 伸缩运行中的应用程序</h3>
<div class="paragraph">
<p>第一个策略允许你移除、添加或重新分配应用程序实例，而不会停止应用程序或影响处理的准确性。只有某些重量级流框架具有这种能力，因为它需要仔细地处理状态和洗牌事件。实例的添加和移除都需要重新分布所有已分配的流分区并从上一个检查点重新加载状态。图 11-6 展示了一个常规的洗牌，其中每个下游的 reduce 操作都从来自上游的 groupByKey 操作产生的洗牌事件中获取数据。如果其中一个groupByKey 实例突然终止了，那么 reduce 节点将不再知道从哪里获得洗牌事件，这会导致致命异常。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image324.png" alt="image324">
</div>
<div class="title">Figure 6. 图 11-6：常规洗牌的逻辑表现</div>
</div>
<div class="paragraph">
<p>Spark 的动态资源分配实现了这种伸缩策略。但是，它需要使用粗粒度模式进行集群部署，并使用外部洗牌服务（external shuffle service，ESS）作为隔离层。如图 11-7 所示，ESS 会接收来自上游任务的</p>
</div>
<div class="paragraph">
<p>洗牌事件，并存储这些事件以供下游任务消费。下游消费者通过向 ESS 问询分配给它们的数据来访问事件。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image325.png" alt="image325">
</div>
<div class="title">Figure 7. 图 11-7：使用 ESS 的逻辑表现</div>
</div>
<div class="paragraph">
<p>现在可以终止任务的执行者 / 实例了，因为下游操作不再依赖于特定的上游实例。如图 11-8 所示，洗牌后的数据保留在 ESS 中，缩容之后的服务可以重新进行处理。在本例中，实例 0 是唯一剩余的处理器，承担着两个分区的任务，而下游操作通过与 ESS 的接口无缝地继续处理。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image326.png" alt="image326">
</div>
<div class="title">Figure 8. 图 11-8：使用 ESS 的已缩容的应用程序（注意实例 1 已经不在了）</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
实时事件流中的洗牌仍然是重量级框架正在开发的一个领域。第 12 章将研究轻量级框架如何直接利用事件代理来扮演 ESS 的角色。</p>
</div>
<div class="paragraph">
<p>谷歌的 Dataflow（所执行的应用程序是用 Beam API 编写的）提供了资源和工作者实例的内置伸缩。Heron 提供了一个（目前处于实验阶段的）健康管理器，它可以使拓扑结构具有动态性和自调节性。此功能仍在开发中，但其旨在实现拓扑的实时、有状态的伸缩。</p>
</div>
<div class="sect3">
<h4 id="_重量级框架的持续改进"><a class="anchor" href="#_重量级框架的持续改进"></a>重量级框架的持续改进</h4>
<div class="paragraph">
<p>在本书英文版出版前不久，Apache Spark 3.0.0 版本发布了。这个版本的一个主要变动是，无须使用 ESS 便可动态调整实例数量。</p>
</div>
<div class="paragraph">
<p>这种模式的工作原理是跟踪生成洗牌文件的阶段，并且当下游作业仍处于活动状态时，就要使生成该数据的执行者保持活动状态。实际上，这个数据源扮演着自己的 ESS 的角色。一旦所有下游作业不再需要它们的洗牌文件，它们还允许进行自我清理。</p>
</div>
<div class="paragraph">
<p>为 ESS 提供专用和持久的独立存储使得 CMS 无法完全扩展作业，因为必须始终投入足够的资源来确保 ESS 可用。Spark 中的这个新的动态伸缩选项说明了重量级框架与 CMS（如Kubernetes）的进一步集成，事实上，它是 JIRA ticket 描述的新特性中提到的主要用例之一。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_11_7_2_通过重启伸缩应用程序"><a class="anchor" href="#_11_7_2_通过重启伸缩应用程序"></a>11.7.2 通过重启伸缩应用程序</h3>
<div class="paragraph">
<p>第二个策略是通过重启对应用程序进行伸缩，所有的重量级流框架都支持该策略。流的消费会暂停，应用程序会创建检查点，然后停止程序。接下来，使用新的资源和并行度重新初始化应用程序，并根据需要从检查点重新加载有状态数据。例如，Flink 提供了一个简单的 REST 机制来实现这个功能，而 Storm 提供了自己的再平衡命令。</p>
</div>
</div>
<div class="sect2">
<h3 id="_11_7_3_自动伸缩应用程序"><a class="anchor" href="#_11_7_3_自动伸缩应用程序"></a>11.7.3 自动伸缩应用程序</h3>
<div class="paragraph">
<p>自动伸缩是根据特定指标自动伸缩应用程序的过程。这些指标可能包括处理延迟、消费者滞后度、内存使用率和 CPU 使用率等。一些框架有自建的自动伸缩选项，比如谷歌的 Dataflow 引擎、Heron 的健康管理器和 Spark Streaming 的动态分配功能。其他框架可能会要求你收集自己的性能和资源利用率指标，并将它们关联到框架的伸缩机制中，比如 14.10 节讨论的滞后度监控工具。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_8_从故障中恢复"><a class="anchor" href="#_11_8_从故障中恢复"></a>11.8 从故障中恢复</h2>
<div class="sectionbody">
<div class="paragraph">
<p>重量级集群被设计为对长期运行的作业所不可避免的故障具有高度的容忍度。主节点、工作者节点和ZooKeeper 节点（如果适用的话）的故障都可得到减轻，以允许应用程序在几乎不中断的情况下继续运行。这些容错功能内置于集群框架中，但在部署集群时可能需要额外的配置。</p>
</div>
<div class="paragraph">
<p>如果工作者节点发生故障，那么在该节点上正在运行的任务就会被转移到其他可用的节点上。任何所需的内部状态都会从最近的检查点与分区分配一起重新加载。主节点故障对于已经执行的应用程序应该是透明的，但是根据集群的配置，在主节点中断期间，你可能无法部署新作业。ZooKeeper（或类似技术）支持的高可用模式可以减少主节点丢失的影响。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
请确保主节点和工作者节点有合适的监控和告警。虽然单个集群节点故障不一定会停止任务处理，但它仍然会降低性能并妨碍应用程序从连续故障中恢复。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_9_考虑多租户问题"><a class="anchor" href="#_11_9_考虑多租户问题"></a>11.9 考虑多租户问题</h2>
<div class="sectionbody">
<div class="paragraph">
<p>随着集群中应用程序数量的增长，除了要考虑集群管理的开销问题，还必须考虑多租户问题。具体来说，应该考虑资源获取的优先级、备用资源与已提交资源的比率，以及应用程序可以声明资源的（伸缩）速率。例如，一个新的从其输入主题的最开始时间开启消费的流应用程序可能会请求并获取大部分的空闲集群资源，从而限制所有当前运行的应用程序获取它们自己的资源。这会导致应用程序达不到其服务级别目标（service-level objective，SLO），并产生下游业务问题。</p>
</div>
<div class="paragraph">
<p>以下是缓解这些挑战的两种方法。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">运行多个小型集群</dt>
<dd>
<p>每个团队或业务单元可以拥有自己的集群，它们跟其他集群完全隔离。最好的方法是，你可以通过编程方式来请求集群资源以保持较低的操作开销（无论是自己开发还是使用第三方供应商）。由于在协调节点（例如，主节点和 Zookeeper 节点）和监控/管理集群方面的开销，这种方法可能会带来较高的财务成本。</p>
</dd>
<dt class="hdlist1">命名空间</dt>
<dd>
<p>一个集群可以划分出多个具有专用资源的命名空间。每个团队或业务小组可以在自己的命名空间内分配自己的资源。在该命名空间内执行的应用程序只能获取这些资源，从而防止它们主动获取其他命名空间的资源而使其他应用程序陷入饥饿状态。此选项的一个缺点是，即使不需要，也必须将备用资源分配给每个命名空间，这可能会导致更大的空闲资源碎片池。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_10_语言和语法"><a class="anchor" href="#_11_10_语言和语法"></a>11.10 语言和语法</h2>
<div class="sectionbody">
<div class="paragraph">
<p>重量级流处理框架植根于其前身的 JVM 语言中，Java 是最常用的，其次是 Scala。Python 也是一种常见的语言，因为它在数据科学家和机器学习专家中很流行，这两类人在这些框架的传统用户中占了很大一部分。MapReduce 风格的 API 是很常用的，其中的操作会链接在一起作为数据集上的固定操作。重量级框架的 API 支持的语言相当有限。</p>
</div>
<div class="paragraph">
<p>类 SQL 的语言也越来越普遍。这使得可以用 SQL 转换来表示拓扑，并且减少了学习新框架的特定 API的认知成本。Spark、Flink、Storm 和 Beam 都提供了类 SQL 语言，尽管它们在功能和语法上有所不同，而且并非所有操作都受支持。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_11_选择一个框架"><a class="anchor" href="#_11_11_选择一个框架"></a>11.11 选择一个框架</h2>
<div class="sectionbody">
<div class="paragraph">
<p>选择重量级流处理框架与选择 CMS 和事件代理非常类似。你必须确定你的组织愿意批准多少运营开销，以及其是否足以支持大规模运行完整的生产集群。这种开销包括常规的操作任务，比如监控、伸缩、故障排除、调试和分配成本，所有这些都是实现和部署实际应用程序所必需的。</p>
</div>
<div class="paragraph">
<p>软件服务供应商可能会将这些平台作为一种服务来提供，尽管选项往往比为 CMS 和事件代理选择供应商更为有限。你要评估可供选择的选项并相应地进行选择。</p>
</div>
<div class="paragraph">
<p>框架的流行度将影响你的决策。Spark 是最流行的框架，Flink 和 Storm 虽没那么流行但仍然在被很多人积极使用。通过 Apache Beam，可以独立于重量级框架的运行时来编写应用程序，尽管这可能对你的组织没有用处。Heron 是 Storm 的一种改进版本，提供了更高级的功能，似乎最不流行。将你在选择 CMS和事件代理时考虑的因素同样应用于选择或放弃重量级框架中来。</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image5.png" alt="image" width="47" height="44"></span>
请记住，一个重量级的流框架并不能合理地实现所有事件驱动型微服务。在决策之前，请确认它是问题空间的正确解决方案。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_12_示例点击和观看的会话窗口"><a class="anchor" href="#_11_12_示例点击和观看的会话窗口"></a>11.12 示例：点击和观看的会话窗口</h2>
<div class="sectionbody">
<div class="paragraph">
<p>想象一下，你现在正在运作一家简易的在线广告公司。你在互联网上购买广告空间并转卖给客户。这些客户想要看到自己的投资回报，这可以用看到广告的用户的点击率来衡量。此外，客户可以按会话计费，其中会话被定义为连续的用户活动，空闲时间不超过 30 分钟。</p>
</div>
<div class="paragraph">
<p>在这个例子中有两个事件流：用户观看广告和用户点击广告。其目标是将这两个流聚合到会话窗口中，并在用户不执行任何新操作的 30 分钟的事件时间（不是挂钟时间）过去后发出会话事件。可以参阅第 6章，对流时间和水位的知识进行复习。</p>
</div>
<div class="paragraph">
<p>通常在收集这些行为事件时，你会期望在值字段中看到其他信息，比如广告发布的位置、用户的 Web 浏览器或设备信息，或者其他各种上下文或元数据。在本例中，观看和点击事件流都简化为表 11-1 所示的基本 schema 格式。</p>
</div>
<div class="paragraph">
<p>表 11-1：基本schema格式的观看和点击事件流</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">键</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">值</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">时间戳</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String userId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long advertisementId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long createdEventTime（创建事件的本地时间）</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>你需要执行以下操作。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将相同的键都编在一组，以保证同一个用户的所有事件都是处理实例的本地事件。</p>
</li>
<li>
<p>使用具有 30 分钟超时的窗口将事件聚合在一起。</p>
</li>
<li>
<p>一旦 30 分钟时限到达，就发出包含一系列事件的窗口事件。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>输出流遵照表 11-2 所示的格式。</p>
</div>
<div class="paragraph">
<p>表 11-2：带有窗口的开始时间和结束时间的输出流</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">键</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">值</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;Window windowId,String userId&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Action[] sequentialUserActions</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这个窗口对象表明了窗口的开始时间和结束时间。这是组合键的一部分，因为随着时间的推移，用户将有多个会话窗口，并且会话窗口可能会在用户之间重复。这个组合键确保了唯一性。值字段中的 Action 对象数组用于按顺序存储操作，并使得微服务可以计算哪些广告的观看导致了可付费的用户点击。Action类如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Action {
    Long eventTime;
    Long advertisementId;
    Enum action; //枚举项为Click和View
}</pre>
</div>
</div>
<div class="paragraph">
<p>以下这个简化的 Apache Flink 源代码使用 MapReduce 风格的 API 显示了该例的拓扑。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>DataStream clickStream = ... //创建点击事件流
DataStream viewStream = ... //创建观看事件流

clickStream
    .union(viewStream)
    .keyBy(&lt;key selector&gt;)
    .window(EventTimeSessionWindows.withGap(Time.minutes(30)))
    .aggregate(&lt;aggregator function&gt;)
    .addSink(&lt;producer to output stream&gt;)</pre>
</div>
</div>
<div class="paragraph">
<p>该拓扑的可视化表示如图 11-9 所示，它使用的并行度是 2（注意有两个单独的实例）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image327.png" alt="image327">
</div>
<div class="title">Figure 9. 图 11-9：来自用户观看和点击的会话创建处理拓扑</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">阶段 1</dt>
<dd>
<p>给每个实例的执行者分配它们的任务，然后反过来将输入事件流的分区分配给它们进行处理。点击流和观看流会被联合到一个单一的逻辑流中，然后根据 userId 键进行分组。</p>
</dd>
<dt class="hdlist1">阶段 2</dt>
<dd>
<p>keyBy 算子，连同下游的 window 算子和 aggregate 算子，需要将现在合并的事件洗牌到正确的下游实例。给定键的所有事件都在同一实例中消费，这为接下来的操作提供了必要的数据局部性。</p>
</dd>
<dt class="hdlist1">阶段 3</dt>
<dd>
<p>现在可以为每个用户生成会话窗口了，每个用户的事件都是单个实例的本地事件。事件按时间戳顺序被添加到本地状态存储中，聚合函数被应用于每个事件，直到检测到 30 分钟或更长时间的中断。此时，事件存储将清除已完成的会话，并在内存中清除 &lt;windowId,userId&gt; 键和值。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><span class="image"><img src="_images/image3.png" alt="image" width="40" height="46"></span>
你所使用的框架也许可以对窗口和基于时间的聚合施加额外的控制（包括保留已关闭一段时间的会话和窗口），以便处理迟到的事件并向输出流发送更新。请查看框架的文档以获得更多信息。</p>
</div>
<div class="paragraph">
<p>接下来，图 11-10 展示了减少到只有一个并行度的效果。假设没有动态伸缩，则需要先停止流处理器，然后通过设置新的并行度从检查点还原它。服务启动时会从最后一个良好的检查点读取有状态的键控数据，并为算子恢复其对应分区的状态。一旦状态恢复，服务就可以恢复正常的流处理。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/image328.png" alt="image328">
</div>
<div class="title">Figure 10. 图 11-10：没有并行度的会话创建处理拓扑</div>
</div>
<div class="paragraph">
<p>阶段 1 的操作与以前一样，不过在本例中，实例 0 中的任务要消费所有分区。分组和洗牌仍在执行，尽管源和目标是在相同的实例上（如阶段 2 中见到的）。请记住，在实例 0 上运行的各个任务都必须消费分配给它们的洗牌事件，尽管这里的所有通信都是完全本地的。在拓扑的最后一个阶段（阶段 3），对事件的窗口化和聚合操作与之前一样。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_13_小结"><a class="anchor" href="#_11_13_小结"></a>11.13 小结</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍了重量级的流处理框架，包括它们的发展简史以及它们在解决问题过程中存在的一些问题。这些系统具有高度可伸缩性，使你可以根据各种分析模式来处理流，但它们可能不足以满足某些有状态的事件驱动型微服务模式的要求。</p>
</div>
<div class="paragraph">
<p>重量级框架使用集中式资源集群进行操作，这可能需要额外的运营开销、监控和协调才能成功地集成到微服务框架中。与容器管理解决方案（如 Kubernetes）集成的创新部署模型，可以更细粒度地部署重量级流处理器，类似于部署完全独立的微服务。</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="10.html">第 10 章 基础的生产者和消费者微服务</a></span>
  <span class="next"><a href="12.html">第 12 章 使用轻量级框架的微服务</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
